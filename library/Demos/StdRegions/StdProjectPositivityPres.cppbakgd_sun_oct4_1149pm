///////////////////////////////////////////////////////////////////////////////
//
// File: NodalDemo.cpp
//
// For more information, please see: http://www.nektar.info
//
// The MIT License
//
// Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
// Department of Aeronautics, Imperial College London (UK), and Scientific
// Computing and Imaging Institute, University of Utah (USA).
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Description: Demo for testing functionality of StdProject
//
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <LibUtilities/Polylib/Polylib.h>
#include "StdDemoSupport.hpp"
namespace po = boost::program_options;

NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff);

//Modification to deal with exact solution for diff. Return 1 if integer < 0.
static double pow_loc(const double val, const int i)
{
    return (i < 0) ? 1.0 : pow(val, i);
}

Array<OneD, NekDouble> V;
Array<OneD, NekDouble> Vd;
Array<OneD, NekDouble> Vall;
Array<OneD, NekDouble> Vallin;
Array<OneD, NekDouble> Vallindx;
Array<OneD, NekDouble> Vallindy;
Array<OneD, NekDouble> Vallin3;
Array<OneD, NekDouble> Valldx;
Array<OneD, NekDouble> Valldy;
Array<OneD, NekDouble> V3;
Array<OneD, NekDouble> Vxm1;
Array<OneD, NekDouble> Vdxxm1;
Array<OneD, NekDouble> Vdyxm1;
Array<OneD, NekDouble> Vx1 ;
Array<OneD, NekDouble> Vdyx1;
Array<OneD, NekDouble> Vdxx1;
Array<OneD, NekDouble> Vdxy1;
Array<OneD, NekDouble> Vdyy1;
Array<OneD, NekDouble> Vy1;
Array<OneD, NekDouble> Vym1;
Array<OneD, NekDouble> Vdxym1;
Array<OneD, NekDouble> Vdyym1;
Array<OneD, Array<OneD, NekDouble> > qZinarr;
//Array<OneD, NekDouble > qWinarr;

// for triangle edges root-finding:
Array<OneD, NekDouble> Vxyhyp;
Array<OneD, NekDouble> Vdxxyhyp;
Array<OneD, NekDouble> Vdyxyhyp;

void  pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector<  NekDouble> >roots,
                          Array<OneD,NekDouble> &pqevalxast = NullNekDouble1DArray,
                    Array<OneD,NekDouble>&fvals = NullNekDouble1DArray 
      
                          );


//declare Do_optimize
void Do_optimize(Array<OneD, NekDouble> &uhats);

//declare find_roots, flag is 0 for confederate matrix approach
vector<vector<  NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d = 0, int flag = 0);

// declare caller routine to find_roots
vector<vector<  NekDouble> > call_find_roots(Array<OneD, NekDouble> &uhatsall, int d = 0, Array< OneD, Array<OneD, NekDouble> >&uhatsedges =NullNekDoubleArrayofArray );


//declare Opt_needed
int Opt_needed(Array<OneD, NekDouble> uhats);

// find eigenvalue
vector< NekDouble> FindEigenval(vector< NekDouble > &CM,
                  int N);

//declare monomial_connection
Array<OneD, Array<OneD, NekDouble> >monomial_connection(int N);

// colleague matrix
Array<OneD, Array<OneD, NekDouble> > formConf(NekDouble N);


// for 2D elements to get uhats at edges
// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,Array<OneD, Array<OneD, NekDouble> >&ret , int d = 0);

// called by project_edges if d = 0 is passed in project_edges
void edgederuhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vdxy, Array<OneD, NekDouble> Vxdy);


// uhatpqd stuff: 
// called by project_edges if d = 1 is passed in project_edges
void edgederpquhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret, int modes,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd, Array<OneD, NekDouble> V3, Array<OneD, NekDouble> qw);

void derpquhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble >&ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> V3, Array<OneD, NekDouble> Vxyd0, Array<OneD, NekDouble> Vxyd1);


// Colleague matrix
Array<OneD, Array<OneD, NekDouble> > C;
StdExpansion *E;
StdExpansion *E3seg;
StdExpansion *E3;
double *a;
double *b;
Array<OneD, NekDouble> qZin; //inner point grid for 2D rootfinding
Array<OneD, NekDouble> qWin; //inner point grid for 2D rootfinding
Array<OneD, NekDouble> qx;
Array<OneD, NekDouble> qw;

int main(int argc, char *argv[])
{
    DemoSupport demo;
    demo.GetOptions().add_options()("optm,z", "positivity preserving optimizer");
    demo.ParseArguments(argc, argv);
    
    po::variables_map vm = demo.GetVariableMap();
    // string shape = vm["shape"].as<string>();
    
    // if(shape == "segment")
    // {
    //     dimension = 1;
    // }
/*
    po::parsed_options parsed_options = po::command_line_parser(argc, argv)
        .options(demo.GetOptions())
        .run();
    std::vector<std::vector<std::string>> lists;
    int dimension = 0;
    for (const po::option& o : parsed_options.options) {
            if (o.string_key == "order")
            {   lists.push_back(o.value);
                dimension = o.value.size();
            } 
            
        }  

    vector<PointsKey> &pkey = demo.GetPointsKey();        
    vector<BasisKey> &bkey = demo.GetBasisKey();
    cout<<"\n dimension = "<<dimension;

    for(int k = 0; k < dimension; k++)
    {
        int coeffsz = std::stoi(lists[0][k]);
        cout<<"coeffsz = "        <<coeffsz<<"\n\n";    
        pkey[k] =  LibUtilities::PointsKey (3*coeffsz, pkey[k].GetPointsType());
        bkey[k] = LibUtilities::BasisKey(bkey[k].GetBasisType(), (coeffsz),  pkey[k]);
    }*/

    //only for 1D
       
    E = demo.CreateStdExpansion();
    if (E == nullptr)
    {
        return 1;
    }
    int dimension = E->GetShapeDimension();
    std::vector<int> order;
    std::vector<BasisType> btype(3, eNoBasisType);
    LibUtilities::ShapeType stype = E->DetShapeType();
    LibUtilities::PointsType pointsTypeCheb = LibUtilities::eGaussGaussChebyshev;

    for (int i = 0; i < dimension; ++i)
    {
        btype[i] = E->GetBasisType(i);
        order.push_back(E->GetBasisNumModes(i));
    }
    //    cout<<"\n order[0] = "<<order[0]<<" order[1]="<<order[1]<<"\n";
    /* if(dimension > 1)
    {
        //prep for gradient descent
        // 5extra points in the interior

    LibUtilities::PointsKey  quadPointsKeyin  (order[0]+5, pointsTypeCheb);  
        qZin = (LibUtilities::PointsManager()[quadPointsKeyin])->GetZ();
    }*/


    //only for seg
    //cout<<"\n 3*order[0]-1="<<3*order[0]-1<<"\n";

    C = formConf(3*(3*order[0]+1));

    //C =monomial_connection(3*(3*order[0]+1)); //+1 for luck
    // print C here:
    /*cout<<"\n C:\n";
    for( int ii = 0; ii <3*( order[0]+1); ii++)
    {
        for(int jj = 0; jj< 3*(order[0]+1); jj++)
        {
            cout<<C[ii][jj]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */    
    const auto totPoints = (unsigned) E->GetTotPoints();

    Array<OneD, NekDouble> x = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> y = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> z = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dx = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dy = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dz = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> sol = Array<OneD, NekDouble>(totPoints);


    switch (dimension)
    {
        case 1:
        {
            E->GetCoords(x);
            break;
        }

        case 2:
        {
            E->GetCoords(x, y);
            break;
        }

        case 3:
        {
            E->GetCoords(x, y, z);
            break;
        }
        default:
            break;
    }

    //get solution array
    for (int i = 0; i < totPoints; ++i)
    {
        //  sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, false)-1.0;
        if(dimension ==2) //only quad
        {
            //sol[i] += sin(M_PI * y[i]) * pow_loc(x[i], 2) +
                //-cos(M_PI * y[i]) * pow_loc(x[i], 1);
             
             sol[i] = pow(sin(x[i]*2),2)+pow((cos(y[i]*2)),2)+pow((y[i]*x[i]),2)-1.2;
        }
        else{
            // dim = 1
            // for _/\_ function:
            // loop through all elements of the vector
            if (fmod(x[i],1.0) < 0.25 || fmod(x[i],1.0) > 0.75)
                sol[i] = 0;
            else if( fmod(x[i],1.0) == 0.25 || fmod(x[i],1.0) == 0.75) 
                sol[i] = 0;
            else if(fmod(x[i],1.0) > 0.25 && fmod(x[i],1.0) < 0.5)
                sol[i] = (fmod(x[i],1.0)-0.25);
            else
                sol[i] = 0.75-fmod(x[i],1.0);
    
    
         
        }
    }

    Array<OneD, NekDouble> phys(totPoints);
    Array<OneD, NekDouble> coeffs((unsigned) E->GetNcoeffs());
    
    //Project onto expansion
    E->FwdTrans(sol, coeffs);

    //Backward transform solution to get projected values
    E->BwdTrans(coeffs, phys);
    
    // check for -ve values and apply opt if necessary
    if (vm.count("optm"))
    {
        int dimension = E->GetShapeDimension(); 
        LibUtilities::PointsKey pkeycheb  (totPoints, pointsTypeCheb);
        LibUtilities::BasisKey bkeycheb(LibUtilities::eChebyshev, 3*(order[0]-1),  pkeycheb);

        E3seg = new StdSegExp(bkeycheb);

        if (E3seg == nullptr)
        {
            return 1;
        }

        vector<PointsKey> &pkey = demo.GetPointsKey();        
        vector<BasisKey> &bkey = demo.GetBasisKey();
        for(int d = 0; d<dimension; d++)
        {
            pkey[d] = pkeycheb;
            bkey[d] = bkeycheb;
        }
        E3 = demo.CreateStdExpansion();

        if (E3 == nullptr)
        {
            return 1;
        }

        Array<OneD, Array<OneD, NekDouble> > qxarr;
    
        qx = E3seg->GetBasis(0)->GetZ();
        qw = E3seg->GetBasis(0)->GetW();
        
        V3 = Array<OneD, NekDouble>(totPoints*(3*(order[0]-1)));

        Array<OneD, Array<OneD, NekDouble> >temp2(1);
        temp2[0] = qx;
        
        for(int pp = 0;  pp<(3*(order[0]-1)); pp++)
        {
            for(int yy =0; yy < qx.size(); yy++)
            {
                V3[qx.size()*pp+yy] = E3seg->PhysEvaluateBasis(Array<OneD, NekDouble>(1,qx[yy]), pp);
            }   
        }
    
        if(dimension == 2 )//&& E->GetNtraces() == 4)
        {

            int totsz = E->GetTotPoints()*E->GetNcoeffs();
            int totszedges = totsz;//E3seg->GetTotPoints()*E3seg->GetNcoeffs();
            //            cout<<"\n E3seg->GetTotPoints()="<<E->GetTotPoints()<<" E3seg->GetNcoeffs()="<<E3seg->GetNcoeffs()<<"\n";
            // populate edge root finding matrices for quadrilateral
            LibUtilities::PointsKey  quadPointsKeyin  (order[0]+5, pointsTypeCheb);
            // for gradient descent
            qZin = (LibUtilities::PointsManager()[quadPointsKeyin])->GetZ();
            qWin = (LibUtilities::PointsManager()[pkeycheb])->GetW();
            //cout<<"\n qWin.sz = "<<qWin.size()<<"\n";

            qxarr = Array<OneD, Array<OneD, NekDouble> >(dimension);
            qxarr[0] = qx;
            qxarr[1] = qx;
            qZinarr = Array<OneD, Array<OneD, NekDouble> >(dimension);
            //            qWinarr = Array<OneD, NekDouble >(pow(qWin.size(),dimension));
            qZinarr[0] = Array<OneD, NekDouble>(pow(qZin.size(),dimension));
            qZinarr[1] = Array<OneD, NekDouble>(pow(qZin.size(),dimension));
                                               //qWinarr = Array<OneD, NekDouble>(pow(qZin.size(),dimension));
            //qWinarr[1] = Array<OneD, NekDouble>(pow(qZin.size(),dimension));
            //      cout<<"\n qwin.sz = "<<qWin.size()<<" ";//exit(0);
            //            int ctr = 0;
            // this loop currently implements 2D only
            // for(int kk = 0; kk<qZin.size(); kk++)
            // {
            //     for(int pp = 0; pp<qZin.size(); pp++)
            //     {
                    
            //         qZinarr[0][ctr] = qZin[kk];
            //         qZinarr[1][ctr] = qZin[pp];
            //         //qWinarr[ctr] = qWin[kk]*qWin[pp];
            //         //                    qWinarr[1][ctr] = qWin[pp];
            //         ctr++;
            //     }
            // }
            qZinarr = demo.GetCoords(E3);

            // ^ was done because we need Vall, Valld, etc
            // evaluated at chebyshev points only

            //to-do: check if ptypes in E already chebyshev,
            //       then don't do the above loop
            Vallin3 = Array<OneD, NekDouble>(qZinarr[0].size()*E3->GetNcoeffs());

            Vall = Array<OneD, NekDouble> (qxarr[0].size()*coeffs.size()); 
            Valldx = Array<OneD, NekDouble> (qxarr[0].size()*coeffs.size());
            Valldy = Array<OneD, NekDouble>(qxarr[0].size()*coeffs.size());

            Vallin = Array<OneD, NekDouble> (qZinarr[0].size()*coeffs.size());     
            Vallindx = Array<OneD, NekDouble> (qZinarr[0].size()*coeffs.size());   
            Vallindy = Array<OneD, NekDouble> (qZinarr[0].size()*coeffs.size()); 
            //            cout<<"\n hi qZinarr sz="<<qZinarr.size()<<" "<<qZinarr[0].size()<<" Vallin sz = "<<Vallin.size()<<"\n\n";            
            E->PhysEvalBasisGrad(qZinarr, Vallin,Vallindx, Vallindy, NullNekDouble1DArray);
            
            E3->PhysEvalBasisGrad(qZinarr, Vallin3, NullNekDouble1DArray, NullNekDouble1DArray,   NullNekDouble1DArray);
            
            Vxm1 = Array<OneD, NekDouble>(totszedges);
            Vdyxm1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vdxxm1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vx1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vdxx1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vdyx1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vdxy1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vdyy1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vy1 = Array<OneD, NekDouble>(totszedges);//sz);
            Vym1  = Array<OneD, NekDouble>(totszedges);//sz);
            Vdxym1  = Array<OneD, NekDouble>(totszedges);//sz);
            Vdyym1  = Array<OneD, NekDouble>(totszedges);//sz);
            Vxyhyp = Array<OneD, NekDouble>(totszedges);
            Vdxxyhyp = Array<OneD, NekDouble>(totszedges);
            Vdyxyhyp = Array<OneD, NekDouble>(totszedges);
            //quadrilateral or tri
            // bot
            //            cout<<"\n totsz = "<<totsz<<"qxarr.sz="<<qxarr[0].size()<<"E->Getnumcoeff()="<<E->GetNcoeffs()<<"\n \n";
   
            qxarr[1] = Array<OneD, NekDouble>(qxarr[0].size(), -1.0);
            E->PhysEvalBasisGrad(qxarr,  Vym1, Vdxym1, Vdyym1, NullNekDouble1DArray);
            // cout<<"\n totsz = "<<totsz<<"qxarr.sz="<<qxarr[0].size()<<"E->Getnumcoeff()="<<E->GetNcoeffs()<<"\n \n";
            
            //top
            qxarr[1] = Array<OneD, NekDouble>(qxarr[0].size(), 1.0); 
            E->PhysEvalBasisGrad(qxarr, Vy1,Vdxy1,Vdyy1, NullNekDouble1DArray);
            
            
            qxarr[1] = qxarr[0];
            // left
            qxarr[0] = Array<OneD, NekDouble>(qxarr[0].size(), -1.0);
            E->PhysEvalBasisGrad(qxarr,Vxm1, Vdxxm1, Vdyxm1, NullNekDouble1DArray);
            // right
            qxarr[0] = Array<OneD, NekDouble>(qxarr[0].size(), 1.0); 
            E->PhysEvalBasisGrad(qxarr, Vx1, Vdxx1, Vdyx1, NullNekDouble1DArray);
            
            // hypotenuse (triangle) y = -x
            
            qxarr[0] = qxarr[1];
            Vmath::Smul(qxarr[0].size(), -1.0, qxarr[0], 1, qxarr[1] , 1);
            E->PhysEvalBasisGrad(qxarr, Vxyhyp,  Vdxxyhyp, Vdyxyhyp, NullNekDouble1DArray);  
            
            
            }
        else if(dimension == 1)
        {
            qxarr = Array<OneD, Array<OneD, NekDouble> >(dimension);
            qxarr[0] = qx;
            
            Vd = Array<OneD, NekDouble>(qx.size()*coeffs.size());
            V = Array<OneD, NekDouble>(qx.size()*coeffs.size());
            //V3 = Array<OneD, NekDouble>(qx.size()*coeffs.size()*3);
            
            E->PhysEvalBasisGrad(qxarr, V, Vd, NullNekDouble1DArray,  NullNekDouble1DArray);
            
            E3seg->PhysEvalBasisGrad(qxarr, V3,  NullNekDouble1DArray, NullNekDouble1DArray,  NullNekDouble1DArray);
            E->PhysEvalBasisGrad(qZinarr, Vallin,Vallindx,  Vallindy, NullNekDouble1DArray);
        }
        /*        cout<<"\n all uhats:\n";
        for(int kk = 0 ; kk < coeffs.size(); kk++)
        {
            cout<<coeffs[kk]<<" ";
            }*/
                      
        if(Opt_needed(coeffs))
        {

            cout<<"\n need optimization\n\n";
            
            Do_optimize(coeffs);
            
            cout<<"\n doopt done\n verifying...\n";//exit(0);
            cout<<"\n do_opt returning uhats\n";
            for(int ii = 0; ii < coeffs.size(); ii++)
                cout<<coeffs[ii]<<" ";
            cout<<"\n";
            if(Opt_needed(coeffs))
            {
                cout<<"\n fail\n\n";
                exit(0);
            }
            else
            {
                cout<<"\n pass\n\n";exit(0);
            }
        }
        else{
            cout<<"\n optimizer no need\n\n";
        }
        //Backward transform solution to get projected values
        E->BwdTrans(coeffs, phys);

    }

    

    /*if (vm.count("diff"))
    {
        for (int i = 0; i < totPoints; ++i)
        {
            sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, true);
        }
    }*/

    //Calculate L_inf & L_2 error
    cout << "L infinity error: \t" << E->Linf(phys, sol) << endl;
    if (stype != ePoint)
    {
        cout << "L 2 error: \t \t \t" << E->L2(phys, sol) << endl;
    }

    if (!vm.count("diff") && stype != ePoint)
    {
        //Evaluate solution at x = y = 0 and print error
        Array<OneD, NekDouble> t = Array<OneD, NekDouble>(3);
        t[0] = -0.5;
        t[1] = -0.25;
        t[2] = -0.3;
        sol[0] = Shape_sol(t[0], t[1], t[2], order, btype, stype, false);

        NekDouble nsol = E->PhysEvaluate(t, phys);

        cout << "Error at x = (";
        for (int i = 0; i < dimension; ++i)
        {
            cout << t[i] << ", ";
        }
        cout << "\b\b): " << nsol - sol[0] << endl;
    }

    // Calculate integral of known function to test different quadrature
    // distributions on each element.
    for (int i = 0; i < totPoints; ++i)
    {
        sol[i] = dimension == 1 ? exp(x[i]) : dimension == 2 ?
            exp(x[i]) * sin(y[i]) : exp(x[i] + y[i] + z[i]);
    }

    NekDouble exact = 0.0;
    switch(stype)
    {
        case eSegment:
            exact = M_E - 1.0 / M_E;
            break;
        case eTriangle:
            exact = -0.5 * (sin(1.0) + cos(1.0) + M_E * M_E *
                            (sin(1.0) - cos(1.0))) / M_E;
            break;
        case eQuadrilateral:
            exact = 2.0 * (M_E - 1.0 / M_E) * sin(1.0);
            break;
        case eTetrahedron:
            exact = 1.0 / M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePrism:
            exact = M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePyramid:
            exact = - 1.0 / M_E / M_E / M_E - 4.0 / M_E + M_E;
            break;
        case eHexahedron:
            exact = pow((M_E * M_E - 1.0) / M_E, 3.0);
            break;
        default:
            ASSERTL0(false, "Exact solution not known.");
            break;
    }
    std::cout << "Integral error: " << fabs(exact - E->Integral(sol))
              << std::endl;

    return 0;
}

// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,    Array<OneD, Array<OneD, NekDouble> >&ret , int d)
{
    int numedges = ret.size();
    int modes = E->GetNcoeffs();
    int modes1D = 3*(E->GetBasis(0)->GetNumModes()-1);
    
    // In case of tri:
    // hypotenuse = 2, bot = 1, left = 2
    
    // assert d = 0 or 1
    if(numedges == 4) //quadrilateral
    {
        
        // bot edge = 0, y = -1
        // right edge = 1, x = 1
        // top edge = 2, y = 1
        // left edge = 3, x = -1
        
    
        //normal projection of der of uhats on quad edges
        if(d == 0) //quadrilateral
        {  
            ret[0] = Array<OneD, NekDouble>(modes);        
            ret[1] = Array<OneD, NekDouble>(modes);
            ret[2] = Array<OneD, NekDouble>(modes);
            ret[3] = Array<OneD, NekDouble>(modes);


            //bot
            edgederuhats(uhats, ret[0], Vall, Vdxym1, Vdyym1);

            //top
            edgederuhats(uhats, ret[1], Vall, Vdxx1, Vdyx1);

            //top
            edgederuhats(uhats, ret[2], Vall, Vdxy1, Vdyy1);
                      
            //left
            edgederuhats(uhats, ret[3], Vall, Vdxxm1, Vdyxm1);
            
            
        }
        
        else // d = 1 so project der to 1D 3*N space
        {
            // uhatpqd stuff:
            //pqeval = -(sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) + (sum(Vxm1.*Vxm1, 2)).*(Vd*c);
            ret[0] = Array<OneD, NekDouble>(modes1D);        
            ret[1] = Array<OneD, NekDouble>(modes1D);
            ret[2] = Array<OneD, NekDouble>(modes1D);
            ret[3] = Array<OneD, NekDouble>(modes1D);
        
            // bot edge
            edgederpquhats(uhats, ret[0], E->GetNcoeffs(), Vym1, Vdxym1, V3, qw);
            // right edge
            edgederpquhats(uhats, ret[1],E->GetNcoeffs(), Vx1, Vdyx1, V3, qw);
            // top edge
            edgederpquhats(uhats, ret[2], E->GetNcoeffs(),Vy1, Vdxy1, V3, qw);
            // left edge
            edgederpquhats(uhats, ret[3], E->GetNcoeffs(),Vxm1, Vdyxm1, V3, qw);
        }
    }
    else if(numedges == 1)
    {
        if(d == 1) // so project der to 3*N space
        {
            ret[0] = Array<OneD, NekDouble>(modes1D);        
            
            edgederpquhats(uhats, ret[0], E->GetNcoeffs(),V, Vd, V3, qw);
            
        }
        else
        {
            ret[0] = uhats;
        }
    }
    else if(numedges == 3) //triangle
    {   
        if(d == 1) // so project der to 3*N space
        {
            ret[0] = Array<OneD, NekDouble>(modes1D);        
            ret[1] = Array<OneD, NekDouble>(modes1D);        
            ret[2] = Array<OneD, NekDouble>(modes1D);        

            // bot edge
            edgederpquhats(uhats, ret[0], E->GetNcoeffs(), Vym1, Vdxym1, V3, qw);
            // left edge
            edgederpquhats(uhats, ret[1], E->GetNcoeffs(), Vxm1, Vdyxm1,V3, qw);
            // hypotenuse     
            edgederpquhats(uhats, ret[2], E->GetNcoeffs(), Vxyhyp, Vdxxyhyp, V3, qw);

        }
        else
        {
            ret[0] = Array<OneD, NekDouble>(modes);        
            ret[1] = Array<OneD, NekDouble>(modes);        
            ret[2] = Array<OneD, NekDouble>(modes);        

            // bot edge
            edgederuhats(uhats, ret[0], Vall, Vdxym1, Vdyym1);

            // left edge
            edgederuhats(uhats, ret[1], Vall, Vxm1, Vdyxm1);
            // hypotenuse                 
            edgederuhats(uhats, ret[2], Vxyhyp,Vdxxyhyp, Vdyxyhyp);
            
        }

    }
        
}


void edgederuhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vdxy, Array<OneD, NekDouble> Vxdy)
{
    int totpts = ret.size();
    Array<OneD, NekDouble> temp(totpts);;
    Array<OneD, NekDouble> vals(totpts);    
    int modes = E->GetNcoeffs();

    for(int k = 0; k < modes; k++)
    {    
        Vmath::Vmul(totpts, &Vdxy[k], totpts, &uhats[0], 1, &vals[0], 1);

        Vmath::Vmul(totpts, &Vxdy[k], totpts, &uhats[0], 1, &temp[0], 1);
        
        Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
        
        Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
        Vmath::Vmul(totpts, &Vxy[k], 1, &vals[0], 1, &vals[0], 1);
        ret[k] = Vmath::Vsum(vals.size(), vals, 1);
        
    }                
    
}

void edgederpquhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  int modes,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd, Array<OneD, NekDouble> V3, Array<OneD, NekDouble> qw)
{
    int uhatstot = uhats.size();
    int totpts = E->GetTotPoints();
    Array<OneD, NekDouble> temp(totpts), temp2(modes), temp3(uhatstot);
    Array<OneD, NekDouble> pqeval(totpts);

    NekDouble v1, v2;
    for(int i = 0; i<totpts; i++)
    {
        Vmath::Vmul(modes, &Vxy[0]+i, totpts, &Vxyd[0]+i, totpts, &temp2[0], 1);

        v1  = Vmath::Vsum(modes, temp2, 1);  

        Vmath::Vmul(uhatstot, &Vxy[i], totpts, &uhats[0], 1, &temp3[0], 1);
        /*        cout<<"\n uhats.size() = "<<uhats.size()<<"modes = "<<modes<<"\n";
        for(int kk = 0; kk< modes; kk++)
        {
                cout<<"\n Vxy["<<kk<<"]*uhats["<<kk<<"]="<<Vxy[i+totpts];
        }
        exit(0);
        */
        v2  = Vmath::Vsum(uhatstot, temp3, 1);  

        /* cout<<"\n uhats:\n";
        for(int kk = 0; kk < uhats.size(); kk++)
        {
            cout<<" "<<uhats[kk]<<" ";
        }        cout<<"\n\n";
        */
      
        v1 = v2*v1;
        //cout<<"\n v1 2 = "<<v1<<"\n";

        // At this point,                 

        // v1 = (sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) for 1 point

        // calculate (sum(Vxm1.*Vxm1, 2)).*(Vd*c)
        Vmath::Vmul(uhatstot, &Vxy[0]+i, totpts, &Vxy[0]+i, totpts, &temp2[0], 1);

        
        //cout<<" v1 = "<<v1<<" "<<"\n\n";;

        v2  = Vmath::Vsum(uhatstot, temp2, 1);  
        
        Vmath::Vmul(uhats.size(), &Vxyd[i], totpts, &uhats[0], 1, &temp2[0], 1);

        //        v1  = Vmath::Vsum(uhats.size(), temp3, 1);  
        v1= v1 - v2*Vmath::Vsum(uhats.size(), temp2, 1);
        
        pqeval[i] = v1;
    }
    //cout<<"\n i \n\n";
    //uhat = (V3)*(wa.*); //pqeval = temp
    //   cout<<"\n pqeval:\n";
    //for(int k = 0; k <pqeval.size(); k++)
    //    cout<<pqeval[k]<<" ";
    //cout<<"\n";
    Vmath::Vmul(totpts, qw, 1, pqeval, 1, pqeval, 1);

    //V3*temp2
    //    for(int i = 0; i<3*(E->GetBasis(0)->GetNumModes()-1); i++)
    //cout<<"\n returning V3 = "<<V3.size()<<" "<<"ret sz = "<<ret.size()<<" totpts="<<totpts<<"\n";

    
    //    cout<<"hererere\n totpts ="<<totpts<<"\t modes="<<modes<<"\t ret.size()="<<ret.size()<<" V3 sz = "<<V3.size()<<" ret.szie() = "<<ret.size()<<" temp sz = "<<temp.size()<<"\n\n";;


    for(int i = 0; i<ret.size(); i++)
    {
        //  cout<<" i*totpts +totpts= "<<i*totpts+totpts<<" ";
        Vmath::Vmul(totpts, &V3[i], totpts, &pqeval[0], 1, &temp[0], 1);
        ret[i] = Vmath::Vsum(totpts, temp, 1);  
        
    }
    //    cout<<"\n totpts ="<<totpts<<"\t modes="<<modes<<"\t ret.size()="<<ret.size()<<"\n\n";;

    //    exit(0);
    
}

Array<OneD, Array<OneD, NekDouble> > formConf(NekDouble N)
{
    int evalPts = N+1; //+1 for luck
    int i, j;       
    Nektar::Array<Nektar::OneD, Nektar::NekDouble> ab1(evalPts);
    Nektar::Array<Nektar::OneD, Nektar::NekDouble> ab2(evalPts);
    Polylib::RecCoeff(evalPts, &ab1[0], &ab2[0], -0.5, -0.5);
    // Form confederate matrix

    /*cout<<"\n abcheb:\n";
      for(int yy = 0; yy<ab1.num_elements(); yy++)
        {
        cout<<ab1[yy]<<" ";
          }
          cout<<"\n";
            for(int yy = 0; yy<ab2.num_elements(); yy++)
              {
              cout<<ab2[yy]<<" ";
                }
                cout<<"\n";
                  
                cout<<"\n";
    */
  
    // a = 2*a
    // b = 2*b
    Vmath::Smul(ab1.size(), 2.0, ab1, 1, ab1, 1);
    Vmath::Smul(ab2.size(), 2.0, ab2, 1, ab2, 1);

    //  J = full(spdiags([[b(3:n);0.5;0] a(1:n) b(1:n)], -1:1, n, n));
    vector<vector<NekDouble> > J;//, Array<OneD, NekDouble>(N,0.0));
      
    vector<NekDouble> row(N);
    NekDouble tt = ab1[0];
    row[0] = tt;
    tt = ab2[1];
    row[1] = tt;
    J.push_back(row);
    for(i = 1; i < N-1; ++i)
    {
        vector<NekDouble> row(N,0.0);
        for(j = 1; j < N-1; ++j)
        {
            if( i == j)
            {
                NekDouble t1 = ab1[i];
                NekDouble t2 = ab2[i+1];
                NekDouble t3 = ab2[i];
                row[j] = t1;
                row[j+1] = t2;
                row[j-1] = t3;
            }
        }
        J.push_back(row);
    }
      
    vector<NekDouble> rowN(N);
    tt = ab1[N-1];
    rowN[N-1] = tt;
    tt = ab2[N-1];
    rowN[N-2] = tt;
    J.push_back(rowN);
      
    //print J:
    
    //cout<<"\n J:\n";
            for(int yy = 0; yy<J.size(); yy++)
            {
            for(int uu  = 0 ; uu<J[0].size(); uu++)
            {
                J[yy][uu] = J[yy][uu]/2;
            }
            //      cout<<"\n";
            }
            //cout<<"\n";
            /*        exit(0);
    */
    Array<OneD, Array<OneD, NekDouble> > C(J.size());
    for(i = 0; i < J.size(); i++)
    {
        C[i] = Array<OneD, NekDouble>(J[i].size(),J[i].data());
        //  Vmath::Vcopy(J[i].size(), , 1, C[i], 1);
    }
    //cout<<"\n\n";
    //print C:
    // cout<<"\n C:\n";
    // for(int yy = 0; yy<C.num_elements(); yy++)
    //   {
    // for(int uu  = 0 ; uu<C[00].num_elements(); uu++)
    //   {
    //     cout<<C[yy][uu]<<" ";
    //   }
    // cout<<"\n";
    //   }
    // cout<<"\n";
      
    return C;
}

vector<vector<  NekDouble> > call_find_roots(Array<OneD,  NekDouble> &uhats , int d, Array<OneD, Array<OneD, NekDouble> >&uhatsedges)
{
    boost::ignore_unused(d);
    int dimension = E->GetShapeDimension(); 
    vector<vector< NekDouble> > ret(dimension);

    if(dimension == 1 )
    {
        //   Array<OneD, NekDouble> uhatd(V3.size());
        //DoProjectpq( uhatd, uhats, V, Vd);

        //for(int kk = 0; kk < uhats.size(); kk++)
        //    cout<<uhats[kk]<<" ";
        ret = find_roots(uhats, 1);
        //        for(int kk = 0; kk < ret[0].size(); kk++)
        //    cout<<ret[0][kk]<<" ";                 
    }
    else if(dimension == 2)
    {
        //cout<<"\n    uhatsedges:";
        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();


        // to-do: assert 2D elements allowed numedges = 3 or 4
        if( numedges == 4)
        {
            // for 2D, structure of roots vector:
            // row 0 vector = bot edge
            // row 1 vector = right
            // row 2 vector = top
            // row 3 vector = left
            // row 4 vector = {x1,x2} inner root
            
            
            for(int ii = 0; ii < numedges; ii++)
            {
                vector<vector<NekDouble> > tmp;
            
                // size of tmp will be dim \times no. of roots
                if(abs(Vmath::Vmin(uhatsedges[ii].size(),uhatsedges[ii],1)) > 1e-9)
                {    
                    //cout<<"\n in\n\n";
                    tmp  = (find_roots(uhatsedges[ii], 0, 0)) ;
                }else
                {

                    // cout<<"\n else\n\n";
                    break;
                }
                for(int p = 0; p < tmp[0].size(); p++)
                {
                    if(ii == 0) // bot edge
                    {
                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(-1);
                        
                    }else if(ii == 1) // right edge
                    {
                        ret[0].push_back(1);
                        ret[1].push_back(tmp[0][p]);
                    }else if(ii == 2) // top edge
                    {
                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(1);
                    
                    
                    }else //if(ii == 3) // left edge
                    {
                        ret[0].push_back(-1);
                        ret[1].push_back(tmp[0][p]);
                    }
                    
                }
                // only for 3D
                //ret[2].push_back(row[2]);
                
            }
        }
        else
        {
            // triangle edge roots code
            // structure of roots vector:
            // row 0 vector = bot edge
            // row 1 vector = left
            // row 2 vector = hypotenuse
            // row 3 vector = {x1,x2} inner root
            for(int ii = 0; ii < numedges; ii++)
            {

                vector<vector<NekDouble> > tmp;
                //                cout<<"\n ii = "<<ii<<" uhatsedges sz = "<<uhatsedges.size()<<" "<<uhatsedges[ii].size()<<"\n\n";   
            
                // size of tmp will be dim \times no. of roots
                if(abs(Vmath::Vmin(uhatsedges[ii].size(),uhatsedges[ii],1)) > 1e-9)
                {    
                    //  cout<<"\n in\n\n";
                    tmp  = (find_roots(uhatsedges[ii], 0, 0)) ;
                }else
                {
                     //cout<<"\n else\n\n";
                    break;
                }          
                for(int p = 0; p < tmp[0].size(); p++)
                {
                    if(ii == 0) // bot edge
                    {
                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(-1);
                        
                    }else if(ii == 1) // left edge
                    {
                        ret[0].push_back(-1);
                        ret[1].push_back(tmp[0][p]);
                    }
                    else //hypt
                    {

                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(-tmp[0][p]);
                        
                        ret[0].push_back(-tmp[0][p]);
                        ret[1].push_back(tmp[0][p]);
                        
                    }
                }
            }
        }
        
        //find interior roots:
        vector<vector<NekDouble> > tmp = (find_roots(uhats, 0, dimension)) ;
        if(tmp[0].size() > 0)
        {
            //    cout<<"\n herereRe?? tmp sz = "<<tmp.size()<<" "<<tmp[0].size()<<"\n\n";
            
            ret[0].push_back(tmp[0][0]);
            ret[1].push_back(tmp[1][0]);
        }
        
    
    }
    else //3D
    {
        cout<<"\n coming soon....2\n";
    }
    //cout<<"\n ret size ="<<ret.size()<<" "<<ret[0].size()<<"\n\n";
    return ret;
}


// Called by call_find_roots depending on edges or interior region 
// rootfinding
// d=1 :: derivatives
// flag = 0, edges (1D rootfinding using confederate matrix)
// flag = 1, interior region rootfinding using gradient descent
vector<vector<NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d, int flag)
{
    int dim = E->GetShapeDimension();
    // to-do assert dimension is 1 2 or 3
    vector<vector< NekDouble> > ret(dim);
    
    //Confederate matrix approach
    if(dim == 1 || flag == 0)
    {
        int N = uhats.size();
        vector<NekDouble> uhatsmon;
        while(abs(uhats[N-1])<1e-8)
        {
            //cout<<"N = "<<N<<"\n";
            N = N-1;
        } 
        vector<NekDouble> temp(N);
        
        // convert uhats to monomial, find roots of uhats or der of uhats
        // uhatsmon = C(1:numModes,1:numModes)'*uhats;
        
        //cout<<"N = "<<N<<" C sz = "<<C.size()<<" "<<C[0].size()<<"\n";
        
        for(int k = 0; k < N; k++)
        {
            for(int jj= 0 ; jj < N; jj++)
            {
                //cout<<C[jj][k]<<" ";
                temp[jj ] = C[jj][k];
            }
            //cout<<"\n";
            Vmath::Vmul(N, &temp[0], 1,  &uhats[0], 1, &temp[0], 1);
            uhatsmon.push_back(Vmath::Vsum(N, &temp[0], 1));
        }

        N = uhatsmon.size();
     

        // truncate trailing zeros
        
        // now size of uhatsmon = N;
        vector<NekDouble> uhatsdiff;
        // if d == 1, 
        
        if(d == 1)
        {
            for(int k = 1; k < N; k++)
            {
                uhatsdiff.push_back(k*uhatsmon[k]);
            }
            N = N-1;
            
        }
        else //d == 0
        {
            uhatsdiff = uhatsmon;
            
        }

        Vmath::Smul(N, 1.0/uhatsdiff[N-1], &uhatsdiff[0], 1, &uhatsdiff[0], 1);
        vector<NekDouble> EIG_R = FindEigenval(uhatsdiff, N);
        //cout<<"\n print done after eigenvals eig_r = "<<EIG_R.size()<<"\n\n";
        
        for(int kk = 0; kk <EIG_R.size(); kk++)
        {
            ret[0].push_back( EIG_R[kk] );
        }
    }
    else if(dim == 2)
    {
        
        // Gradient descent
        //        cout<<"\n gradient descent\n\n";
        
        //call pq instead of roots = quad points,
        // convert qZinarr to vec<vec<>>
        int totinteriorpts = qZinarr[0].size(); 
        vector<vector<NekDouble>  > qZinvec;
        vector<NekDouble> row;
        vector<NekDouble> row2;
        
        Array<OneD, NekDouble > retderpquhats(E3->GetNcoeffs());
        
        for(int kk = 0; kk < totinteriorpts; kk++)
        {
            row.push_back(qZinarr[0][kk]);
            
        }
        qZinvec.push_back(row);
        for(int kk = 0; kk < totinteriorpts; kk++)
        {
            row2.push_back(qZinarr[1][kk]);
            
        }
        qZinvec.push_back(row2);
        

        //        cout<<"\n totinteriorpts = "<<totinteriorpts<<"\n\n";
        derpquhats(uhats,  retderpquhats, Vallin, Vallindx, Vallindy, Vallin3  );
        //cout<<"\n retderpquhats\n";
        /*for(int kk = 0; kk < E3->GetNcoeffs(); kk++)
        {
            cout<<" "<<retderpquhats[kk]<<" ";
        }
        cout<<"\n totinteriorpts = "<<totinteriorpts<<"\n\n";
        */
        // Assert that d = 0
        // Gradient descent: to find optima of uhatder
        //cout<<"\n gradient descent\n";
        int num = E3->GetNcoeffs(); 
        Array<OneD, NekDouble> temp(num);
        std::vector< std::vector<NekDouble> > R;
        Array<OneD, NekDouble> g(2);
        Array<OneD, NekDouble> evald0(num),evald1(num);
        double inf = numeric_limits<double>::infinity();

        int ii,jj;//kk, 
        int ctrn = 0;
        NekDouble x1new = 0, x2new = 0;
        NekDouble x1, x2, gprev = inf; // use inf
        for(ii = 0; ii < qZin.size(); ++ii)
        {
            for(jj = 0; jj < qZin.size(); ++jj)
            {
                //vector< vector< NekDouble> >xarr;
                x1 = qZin[ii], x2 = qZin[jj];
                vector<vector<NekDouble> > xarr;
                vector<NekDouble> row, row1;
                row.push_back(x1);
                xarr.push_back(row);
                row1.push_back(x2);
                xarr.push_back(row2);
                Array<OneD, NekDouble> ret(1);
               
                pq(uhats,xarr, NullNekDouble1DArray, ret  );;                   
                if(g[0]<gprev)
                {
                    x1new = x1;
                    x2new = x2;
                    gprev = ret[0];
                    
                }
                ctrn++;
            }
        }
        
        int n = 0;
        NekDouble epsl = 1.0;

        cout<<"starting\n x1 = "<<x1new<<" x2 = "<<x2new<<"epsl = "<<epsl<<"gprev="<<gprev<<"\n\n";
        NekDouble stepsize = 1e-4, iter = 1e4;
        Array<OneD, Array<OneD, NekDouble> > xastaa(2);
        int flag = 0;

        // loop for gradient descent 2D:
        while(n < iter && flag == 0)
        {

            if(abs(x1new)<1e-12)
                x1new = 0.0;
            if(abs(x2new)<1e-12)
                x2new = 0.0;
            if(stepsize < 1e-10)
            {
                cout<<"\n break! n = "<<n<<" epsl = "<<epsl<<"x="<<x1new<<" y="<<x2new<<"\n";
                break;
                
            }
            xastaa[0] = Array<OneD, NekDouble>(1,x1new);
            xastaa[1] = Array<OneD, NekDouble>(1,x2new);
            E3->PhysEvalBasisGrad(xastaa,NullNekDouble1DArray, evald0, evald1, NullNekDouble1DArray );

            Vmath::Vmul(num, &evald0[0], 1, &retderpquhats[0], 1, &temp[0], 1);          
            g[0] = Vmath::Vsum(num, temp, 1);
            
            Vmath::Vmul(num, &evald1[0], 1, &retderpquhats[0], 1, &temp[0], 1);
            g[1] = Vmath::Vsum(num, temp, 1);
            epsl = abs(g[0])+abs(g[1]);
          
            //cout<<"\n n = "<<n<<" epsl = "<<epsl<<" stepsize ="<<stepsize<<" g0 = "<<g[0]<<" g1="<<g[1]<<"\n\n";
            /*            if(epsl>1)
            {
                epsl = 1;
                stepsize = stepsize/10;
                
                //restart with smaller step size
                x1 = x1new - stepsize*(g[0]);
                x2 = x2new - stepsize*(g[1]);
                x1new = x1;
                x2new = x2;
                
                //        x1new = savex1;
            //   x2new = savex2;
                
                continue;
                }*/
            if(epsl <1e-10 && abs(x1new)<=1.0 && abs(x2new)<=1.0)
            {
                cout<<"\n break! n = "<<n<<" epsl = "<<epsl<<"x="<<x1new<<" y="<<x2new<<"\n";
                flag = 1;
                break;
            }
            
            x1 = x1new - stepsize*(g[0]);
            x2 = x2new - stepsize*(g[1]);
            x1new = x1;
            x2new = x2;
            n = n+1;
        }
        if(n>iter)
        {
            cout<<"\n epsl = "<<epsl<<"\n";
            exit(0);
        }
        cout<<"\n n = "<<n<<" epsl = "<<epsl<<" x1 ="<<x1new<<" x2="<<x2new<<"\n";

        //check
        // third condition is only for tri:
        if(abs(x1)<=1.0 && abs(x2)<=1.0)// && x1+x2<=0.0)
        {
            
            ret[0].push_back(x1);   
            ret[1].push_back(x2);   
        }
    }
    else{
        
        cout<<"\n Dimension 3 coming soon...\n";
    }

    //    cout<<"\n ret from find_roots ret ="<<ret.size()<<"\n\n";
    return ret;    

}
    
    
Array<OneD, Array<OneD, NekDouble> > monomial_connection(int N)
{

    Array<OneD, Array<OneD, NekDouble> > R(N);
    a = new double[N];
    b = new double[N];    


    // Initialize a and b to zero
    for(int i = 0; i < N; i++)
    {
        a[i] = 0.0;
        b[i] = 0.0;
    }
    
    // [a,b] = jacobi_recurrence(maxN+1, 0, 0);
    
    Polylib::RecCoeff(N, a, b, 0.0, 0.0);
    //cout<<"\n a and b:\n";
    
    
    //     assert( (N >= numel(a)) && (N >= numel(b)) );

    //b = sqrt(b)
    transform(b, b+N, b, (double(*)(double)) sqrt);
    //b = 1./b
    Array<OneD, NekDouble> r(N, b);
    for(int i = 0; i<r.size(); i++)
    {
        r[i] = 1/r[i];
    }

   // local_leading_coeffs = cumprod(1./b);

    //r = cumprod(1./b) 
    partial_sum (r.begin(), r.end(), r.begin(), multiplies<double>());

    /*    cout<<"\n r:\n";
for(int i = 0; i<N; i++)
    {
        cout<<r[i]<<" ";   
        }*/

    //Build the connection matrix for this dimension and then distribute it accordingly

    for(int i = 0; i<N; i++)
    {
        Array<OneD, NekDouble> row(N);
        for(int j = 0; j<N; j++)
        {
            if( i == j)
            {
                row[i] = r[i];
            }

        }
            R[i] = row;

    }

    //print R:
    /*    cout<<"\n R=\n";
    for(int i = 0; i<N; i++)
    {
        for(int j = 0; j<N; j++)
        {
            cout<<R[i][j]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */
    for(int i = 1; i<N; i++)
    {
        //"side" conditions (i.e. those w/o left/right boundary points)
        if(i<2)
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0]);
        }
        else
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0] - b[i-1]*R[i-2][0]);
            
            //All the rest are `vectorizable'
            for(int j = 1; j<i-1; j++)
            {
                R[i][j] = R[i-1][j-1] - a[i-1]*R[i-1][j] - b[i-1]*R[i-2][j];
                R[i][j] = R[i][j]/b[i];
            }
            
        }
    }
    /*  Array<OneD, Array<OneD, NekDouble> > Rtrans(R);
    for(int i = 0; i < R.size(); i++)
    {
        for(int j = 0; j < R[0].size(); j++)
        {
            Rtrans[i][j] = R[j][i];
        }
    } */

    return R;

}

// convert fn val at quad points -> uhats of der of function
void derpquhats(Array<OneD, NekDouble> &uhats, Array<OneD,  NekDouble >&ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> V3, Array<OneD, NekDouble> Vxyd0, Array<OneD, NekDouble> Vxyd1)
{
    Array<OneD, NekDouble> holdx(E3->GetNcoeffs());
    Array<OneD, NekDouble> holdy(E3->GetNcoeffs());
    
    edgederpquhats(uhats, holdx, holdx.size(), Vxy, Vxyd0, V3, qWin);
    
    edgederpquhats(uhats, holdy, holdy.size(), Vxy, Vxyd1, V3, qWin);

    
    Vmath::Vadd(holdx.size(), holdx, 1, holdy, 1, ret, 1);
}

vector< NekDouble> FindEigenval( vector<NekDouble> &uhatsdiff,
                   int N) 
{    
    boost::ignore_unused(N);
    int sizemat = uhatsdiff.size();
    Array<OneD, NekDouble> CMdiff(pow(sizemat-1,2),0.0);

//cout<<"\n cmdiff size = "<<CMdiff.size()<<"\n\n";
// Form companion matrix for maxima/minima
// CMdiff = eye(length(uhatsdiff)-2);
// and
    // CMdiff = [CMdiff -uhatsdiff(2:end-1)];
    // and
    // CMdiff = [[zeros(1,length(uhatsdiff)-2) -uhatsdiff(1)]; CMdiff];

/*for(int k = 0; k <sizemat; k++)
    {
        cout<<uhatsdiff[k]<<" ";
    }
cout<<"\n\n";*/
    for(int k = 1; k < sizemat-1; k++)
    {
        
        CMdiff[(k)*(sizemat-1) +k-1] = 1.0;
        CMdiff[(k+1)*(sizemat-1)-1 ] = -uhatsdiff[k];
    }    

    
    //CMdiff[0] = temp1;
    //temp1[N-2] = -uhatsdiff[0];
    //Vmath::Vcopy(N-1, &temp1[0], 1, &CMdiff[0][0], 1);
    //    CMdiff[0][uhatsdiff.size()-2] = -uhatsdiff[0];
    CMdiff[sizemat-2] = -uhatsdiff[0]; 

    const int sz = sizemat-1;//pow(CMdiff.size(),0.5);
    Array<OneD, NekDouble> Mat(sz*sz,0.0);
    const int  lwork = 3*(sz);

    Array<OneD, NekDouble> work1(lwork), EIG_temp(sz), EIG_I(sz);
    //    NekDouble *work1[lwork];
    //NekDouble *EIG_temp[sz];
    //NekDouble *EIG_I[sz];

    //cout<<"\n\n CMdiff=\n";
 
   //print CMdiff transpose
        for(int ii = 0; ii<CMdiff.size(); ii++)
    {
        {
            //      cout<<CMdiff[ii]<<" ";
            
        }
    }
        //    cout<<"\n\nMat=";

    //print CMdiff transpose
    for(int ii = 0; ii<sz; ii++)
    {
        for(int jj = 0; jj<sz; jj++)
        {   
            {
                Mat[ii*(sizemat-1)+jj] = CMdiff[jj*(sizemat-1)+ii];
          
            }
        }
    }
    /*    cout<<"\n\n Mat=\n";
    
   //print CMdiff transpose
        for(int ii = 0; ii<sz*sz; ii++)
    {
        {
            cout<<Mat[ii]<<" ";
            
        }
    }
    cout<<"\n\n";
    */
    int info = 0;
    
    
    char jobvl = 'N';
    char jobvr = 'N';

    NekDouble dum1, dum2;
    
    Lapack::Dgeev(jobvl,jobvr,sz,Mat.get(),sz,EIG_temp.get(),EIG_I.get(),&dum1,1,&dum2,1,&work1[0],lwork,info);
   
    vector<NekDouble>EIG_R;// (ctr, EIG_temp.data());
    
    for(int k = 0; k < sz; k++)
    {
        //cout<<"\n"<< EIG_temp[k]<<" "<<EIG_I[k];
        if(abs(EIG_I[k])<1e-8 && abs(EIG_temp[k])<=1.0)
        {
            EIG_R.push_back(EIG_temp[k]);
        }
    }
    
    EIG_R.push_back(-1.0);
    EIG_R.push_back(1.0);

    //cout<<"\n eigenvals\n:";

    //for(int ii = 0; ii < EIG_R.size(); ii++)
        //    cout<<EIG_R[ii]<<" ";
    //    cout<<"\n print done\n\n";
    //cout<<"\n print done: EIG_R:"<<EIG_R[0]<<" "<<EIG_R[1]<<"\n\n";

    return EIG_R;
}

int Opt_needed(Array<OneD, NekDouble> uhats)
{

    int dimension = E->GetShapeDimension();

    int totModes = uhats.size();
    vector<vector<  NekDouble> > roots;
 

    if( dimension == 3)
    {
        cout<<"\n coming soon...\n";
    }
    if( dimension == 2)
    {

        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();
        Array<OneD, Array<OneD, NekDouble> > edgeuhats  (numedges);
        project_edges(uhats, edgeuhats);

        //find roots of der of uhats, that is why d = 0
        roots = call_find_roots(uhats, 0, edgeuhats);

 
    }
    else if(dimension == 1)
    {
        // find roots of der of uhats, that is why d = 1
        roots = call_find_roots(uhats, 1);
        
        
    }   

    /*    cout<<"\n optima in opt_needed: "<<roots.size()<<"\n";
        for(int pp = 0; pp < roots.size(); pp++)
        {
            for(int jj = 0; jj < roots[0].size(); jj++)
            {
                cout<<roots[pp][jj]<<" ";
            }
            cout<<"\n";
        }
        cout<<"\n";
    */  
    Array<OneD, Array<OneD,  NekDouble> > rootsarr(roots.size());
        
        
        for(int ii = 0; ii < roots.size(); ii++)
        {
            rootsarr[ii] = Array<OneD, NekDouble>(roots[ii].size(), roots[ii].data());
        }
 
    // evaluate ortho basis at roots
    // evalBasisRoots is flattened basis eval matrix
    int     evalsz = (roots[0].size())*totModes;
    Array<OneD, NekDouble> evalBasisRoots(evalsz);
 
    E->PhysEvalBasisGrad(rootsarr, evalBasisRoots, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
  
   Array<OneD, NekDouble> tmp(roots.size());
    
    /*    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        for(int jj = 0; jj <totModes; jj++)
        {
            //            cout<<"\n diededede ii = "<<ii<<"jj = "<<jj<<"roots[0].size()="<<roots[0].size()<<" evlbasroots sz="<<evalBasisRoots.size()<<" totmodes = "<<totModes<<" jj + roots[0].size()*ii = "<<jj + roots[0].size()*ii<<"\n\n";

            for(int kk = 0; kk < roots.size(); kk++)
            {
                tmp[kk] = roots[kk][ii];
            }
            evalBasisRoots[jj + roots[0].size()*ii] = (E->PhysEvaluateBasis(tmp, jj));
        }
    }*/
    

    // vals = evalBasisRoots \times uhats 
    //cout<<"\n in opt_needed\n";
    Array<OneD, NekDouble> vals(roots[0].size()), temp(totModes);
    for(int k = 0; k < vals.size(); ++k)
    {

        Vmath::Vmul(totModes, &evalBasisRoots[k], vals.size(), &uhats[0], 1, &temp[0], 1);
        vals[k] = Vmath::Vsum(temp.size(), temp, 1);
    }
 
    NekDouble minv = Vmath::Vmin(vals.size(), vals, 1);	
    int idx = Vmath::Imin(vals.size(), vals, 1);

    if(roots.size()==2)
    {
        cout<<"\n minv = "<<minv<<" at "<<roots[0][idx]<<" "<<roots[1][idx]<<
        "\n\n";
    }else if(roots.size() == 1)
    {
        cout<<"\n minv = "<<minv<<" at "<<roots[0][idx]<<" ";
    }
    
    if(minv < 0.0 && abs(minv)>1e-10)
    {
        return 1;
    }
    return 0;
}

void pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector< NekDouble> > roots,
                          Array<OneD,NekDouble> &pqevalxast,
          
        Array<OneD,NekDouble> &fvals)
{

    int N = uhats.size();
    vector< NekDouble> V1;
    vector<NekDouble> Vsumsq;//, fvals;//(roots[0].size());
    int dim = E->GetShapeDimension();
    Array<OneD,NekDouble> wsp1(N);
// V1 is flattened basis eval matrix
    // int     evalsz = roots[0].size()*N;
    /*cout<<"\n optima in pq sz = "<<roots.size()<<" "<<roots[0].size()<<"\n\n";
    for(int ii = 0; ii < roots[0].size(); ii++)
     {
        cout<<        roots[0][ii]<<" ";
     }
    cout<<"\n";*/

    // eval basis at roots
    /*        cout<<"\n uhats in pq:\n";
    for(int ii = 0; ii < uhats.size(); ii++)
    {
        cout<<        uhats[ii]<<" ";
    }
    cout<<"\n\n";
    */
    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        Array<OneD, NekDouble> tmparr(dim);
        for(int k = 0; k<dim; k++)
        {
            tmparr[k] = roots[k][ii];
        }
        for(int jj = 0; jj <N; jj++)
        {
            V1.push_back(E->PhysEvaluateBasis(tmparr, jj));
        }
    }
    // V2 = mat_mat_dot(V1,V1);
    // and
    // vector<double> Vsum = mat_sum_dim(V2,2);

    //    cout<<"\n V.*V=\n";
    for( int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &V1[i*N], 1, &wsp1[0], 1);

        Vsumsq.push_back(1.0/pow(Vmath::Vsum(N, &wsp1[0], 1),0.5));
    }

    /*    cout<<"\n cfun(opt)\n:";
    for(int ii = 0; ii<roots[0].size(); ii++)
        cout<<Vsumsq[ii]<<" ";
    cout<<"\n\n";
    */
    //vector<double> mv = mat_vec(V1,uhats);
    //cout<<"\n numerator:\n\n";
    //    cout<<"\n fvals:\n";
    for(int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &uhats[0], 1, &wsp1[0], 1);
        fvals[i] = ( Vmath::Vsum(N, &wsp1[0], 1));
        //        cout<<fvals[i]<<" ";

    }

    //cout<<"\n\n";
    //    cts = vec_vec_dot(Vsumsq, ret);
    Vmath::Vmul(roots[0].size(), &Vsumsq[0], 1, &fvals[0], 1, &fvals[0], 1);

    if(pqevalxast.size() > 0)
    {
        int minidx = Vmath::Imin(fvals.size(), &fvals[0], 1);
        pqevalxast[0] = fvals[minidx];
        for(int k = 0; k < pqevalxast.size()-1; k++)
        {
            pqevalxast[k+1] = roots[k][minidx];
        }
    }
     
}


void Do_optimize(Array<OneD, NekDouble> &uhats)
{

    int dim = E->GetShapeDimension();
    int numedges = 1;
    if(dim>1)
    {
        numedges = E->GetNtraces();
    }

    // uhats[0] =  0.331730709814333;
    // uhats[1] =   0.459076341659940;
    // uhats[2] =   0.363919276512675;
    // uhats[3] =  -0.056672051052144;
    // cout<<"\n in do_opt: uthas.size() = "<<uhats.size()<<"\n";
    double inf = numeric_limits<double>::infinity();
    //assert(size(constraints, 1) == N+2);
    int N1 = uhats.size();
    vector<Array<OneD,NekDouble> > d;
    d.push_back(uhats);
    int counter = 0;

    //    int NC = ck[1].size();          // number of constraints
    vector<double> tols;         // constraint specific tolerances

    int niter = 1e3;
    vector< vector<NekDouble> > optima;
    
    //    int NC = 1; //number of constraints, only positivity for now
    tols.push_back(1e-11);
    Array<OneD, NekDouble>  pqvalxast(dim+1), xastarr(dim), utemp, wsp1(N1);   
    Array<OneD, Array<OneD, NekDouble> > Pf(numedges);
    
   //    Array<OneD, Array<OneD, NekDouble> >;
    NekDouble pqval;//, minel;// minidx;
  
   while (counter <= niter)
    {
        
        pqval = inf;
        
        //cout<<"\n counter = "<<counter<<"\n\n";       
        utemp = d.back();
        //        cout<<"\n at counter "<<counter<<" init uhats = ";
        //for(int kk = 0; kk < N1; kk++)
        //    cout<<utemp[kk]<<" ";
        //cout<<"\n";
        //pq = @(xx) cfun(xx) .* (constraints(1,jj).*Vc(xx)*uhats);          
        project_edges(utemp, Pf, 1);
        /*        cout<<"\n Pf:\n\n";
        for(int kk = 0; kk <Pf.size(); kk++)
        {
            for(int ll = 0; ll < Pf[0].size(); ll++)
            {
                cout<<Pf[kk][ll]<<" ";
            }
            cout<<"\n";
            }*/
        
        //cout<<"\n\n\n\n";
        //exit(0);
        optima = (call_find_roots(utemp, 0, Pf));
        /*
        cout<<"\n optima in do_opt: "<<optima.size()<<"\n";
        for(int pp = 0; pp < optima.size(); pp++)
        {
            for(int jj = 0; jj < optima[0].size(); jj++)
            {
                cout<<optima[pp][jj]<<" ";
            }
            cout<<"\n";
        }
        cout<<"\n";*/
        //exit(0);
        /*        cout<<"\n uhatpqd: ";
        for(int ii = 0; ii<Pf.size(); ii++)
            cout<<Pf[ii]<<" ";
        cout<<"\n";
        */
        pq(utemp, optima, pqvalxast, wsp1);
           
        //        cout<<"\n pq returns:\n\n";
        //cout<<"pqval = "<< pqvalxast[0] <<" xast = "<< pqvalxast[1]<<"pqval = "<<pqval<<"\n\n";   

        if (pqvalxast[0] < pqval)
        {
            for(int k = 0; k  < dim; k++)
            {
                xastarr[k] = pqvalxast[k+1];//optima[0][minidx];
            }
            pqval = pqvalxast[0];
            //jval = jj; //<- use for multiple constraints
        }
        
        //}
        if(xastarr.size() == 2)
        {
            cout<<"\n at counter="<<counter<<" min val="<<pqval<<" xast ="<<xastarr[0]<<" "<<xastarr[1]<<
            "\n\n";
        }
        else if(xastarr.size() == 1)
        {
    cout<<"\n at counter="<<counter<<" min val="<<pqval<<" xast ="<<xastarr[0]<<"\n\n";
        
        }
        // If minimum is non-negative, we're done
        if (pqval >= -tols.at(0))
        {
            break;
        }
        
        vector<NekDouble> Vastsq;
        vector<NekDouble> Vast;
        
        NekDouble vastsqsum;
        
        //Vast= poly_eval(xastv,N1,ck[1][jval]);
        //Vastsq = mat_mat_dot(Vast,Vast);
        //cout<<"\n N1 = "<<N1<<"\n";
        
        for( int ii = 0; ii < N1; ii++)
        {
            Vast.push_back(E->PhysEvaluateBasis(xastarr, ii));
            Vastsq.push_back(Vast[ii]*Vast[ii]);
        
        }
        //cout<<"\n heredasdas N1="<<N1<<"\n\n";     
        
        //Vmath::Vmul(N1, &Vast[0], 1, &Vast[0], 1, &Vastsq[0], 1);
        vastsqsum = Vmath::Vsum(N1, &Vastsq[0], 1);

        Array<OneD, NekDouble>  qast(N1);

        for(int i = 0; i<N1; i++)
        {
            qast[i] = ((1/sqrt(vastsqsum))*(Vast[i]));
        }
        Vmath::Smul(N1, pqval, &qast[0], 1, &qast[0], 1);
        
        Vmath::Vsub(utemp.size(), &utemp[0], 1, &qast[0], 1, &qast[0], 1);
        d.push_back(qast);
        /*
        cout<<"\n at counter = "<<counter<<" final uhats:;\n";
        for(int ii = 0; ii < qast.size(); ii++)
            cout<<qast[ii]<<" ";
        cout<<"\n";
        */
        counter = counter + 1;
    
    
    }
    cout<<"sphere_rotation took "<<counter<<"  iterations\n ";
    uhats = d.back();
}


// Array<OneD, Array<OneD,NekDouble> > uhatpqd(
//                                         Array<OneD, NekDouble > c, 
//                                         Array<OneD, NekDouble > qw, 
//                                         Array<OneD, NekDouble > V,
//                                         Array<OneD, NekDouble > Vd,
//                                         Array<OneD, NekDouble > V3
//                                         )
// {

//     int dim = E->GetShapeDimension();

//     Array<OneD, Array<OneD,NekDouble> > ret(dim); 
//     Array<OneD, NekDouble> temp(qw.size()), pqeval(qw.size());
//     //pqeval = -(sum(V(:,:,1+d).*V(:,:,2+d), 2)).*(V(:,:,1+d)*c) + (sum(V(:,:,1+d).*V(:,:,1+d), 2)).*(V(:,:,2+d)*c);
//     cout<<"\n c ="<<c.size()<<"\n";
//     cout<<"\n Vd = "<<Vd.size()<<"\n";       
//     for(int ii = 0; ii<Vd.size(); ii++)
//         cout<<Vd[ii]<<" ";
//     cout<<"\n";

//     //Vd*c
//     cout<<"\n Vd*c=\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &Vd[i], qw.size(), &c[0], 1, &ret[0], 1);
//         temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
//         cout<<" "<<temp[i];
//     }

//     //temp * sum(V.*V,2)
//     cout<<"\n prev*sum(V.*V,2:\n";
//     //    cout<<"\n pqeval:\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &V[i], qw.size(), &ret[0], 1);
//         //cout<<" "<< Vmath::Vsum(c.size(), &ret[0], 1);
    
//         pqeval[i] = temp[i] * Vmath::Vsum(c.size(), &ret[0], 1);
//         cout<<pqeval[i]<<" ";
    
//     }

//     //V*c
//     //cout<<"\nVc\n\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &c[0], 1, &ret[0], 1);
//         temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
//         //   cout<<temp[i]<<" ";
//     }

//     //temp*sum(V.*Vd,2)
//         cout<<"\n temp*sum(V.*Vd,2):\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &Vd[i], qw.size(), &ret[0], 1);
//         NekDouble tt= (Vmath::Vsum(c.size(), &ret[0], 1));
//         pqeval[i] =  pqeval[i] - temp[i] * tt;
//         cout<<tt<<" ";
//     }
//         cout<<"\n\n";
    
//     //pqeval = vec_vec_dot(pqeval, qw);

//     /*cout<<"\n pqeval ="<<pqeval.size()<<"\n";
//     for(int ii = 0; ii<pqeval.size(); ii++)
//         cout<<pqeval[ii]<<" ";
//     cout<<"\n qw ="<<qw.size()<<"\n";
//     for(int ii = 0; ii<qw.size(); ii++)
//         cout<<qw[ii]<<" ";
//     */
//     Vmath::Vmul(qw.size(), &pqeval[0], 1, &qw[0], 1, &pqeval[0], 1);
//     Array<OneD, NekDouble> rettemp(qw.size()), rettemp2(qw.size());
//     //    ret = mat_vec(mat_T(V3),ret);
//     cout<<"\n uhatpqd: qw.size()="<<qw.size()<< " "<<pqeval.size();
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(qw.size(), &pqeval[0], 1, &V3[0]+i*qw.size(), 1, &rettemp[0], 1 );
//         rettemp2[i] = Vmath::Vsum(qw.size(), &rettemp[0], 1);
//          cout<<rettemp2[i]<<" ";
//     }
//     //cout<<"\n\n";

//     return rettemp2;
// }



NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff)
{
    map<ShapeType, function<int(int, const vector<int> &)>> shapeConstraint2;
    shapeConstraint2[ePoint] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eSegment] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eTriangle] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[eQuadrilateral] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eTetrahedron] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePyramid] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePrism] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eHexahedron] =
            [](int,   const vector<int> &order) { return order[1]; };

    map<ShapeType, function<int(int, int, const vector<int> &order)>>
            shapeConstraint3;
    shapeConstraint3[ePoint] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eSegment] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTriangle] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eQuadrilateral] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTetrahedron] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePyramid] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePrism] =
            [](int k, int,   const vector<int> &order) { return order[2] - k; };
    shapeConstraint3[eHexahedron] =
            [](int,   int,   const vector<int> &order) { return order[2]; };

    NekDouble sol = 0.0;
    if (!diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += sin(k * M_PI * x) + cos(k * M_PI * x);
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eSegment)
        {
            sol += 0.25 * sin(M_PI * x) + 0.25 * cos(M_PI * x);
        }
        else if (btype[0] == eFourier && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1] / 2; ++l)
                    {
                        sol += sin(k * M_PI * x) * sin(l * M_PI * y) +
                               sin(k * M_PI * x) * cos(l * M_PI * y) +
                               cos(k * M_PI * x) * sin(l * M_PI * y) +
                               cos(k * M_PI * x) * cos(l * M_PI * y);
                    }
                }
            }
            else if (btype[1] == eFourierSingleMode)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    sol += sin(k * M_PI * x) * sin(M_PI * y) +
                           sin(k * M_PI * x) * cos(M_PI * y) +
                           cos(k * M_PI * x) * sin(M_PI * y) +
                           cos(k * M_PI * x) * cos(M_PI * y);
                }
            }
            else
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1]; ++l)
                    {
                        sol += sin(k * M_PI * x) * pow_loc(y, l) +
                               cos(k * M_PI * x) * pow_loc(y, l) ;
                    }
                }
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(M_PI * x) * sin(l * M_PI * y) +
                           sin(M_PI * x) * cos(l * M_PI * y) +
                           cos(M_PI * x) * sin(l * M_PI * y) +
                           cos(M_PI * x) * cos(l * M_PI * y);
                }

            }
            else if (btype[1] == eFourierSingleMode)
            {
                sol += sin(M_PI * x) * sin(M_PI * y) +
                       sin(M_PI * x) * cos(M_PI * y) +
                       cos(M_PI * x) * sin(M_PI * y) +
                       cos(M_PI * x) * cos(M_PI * y);
            }
            else
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += sin(M_PI * x) * pow_loc(y, l) +
                           cos(M_PI * x) * pow_loc(y, l);
                }
            }
        }
        else if (btype[1] == eFourier && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(l * M_PI * y) * pow_loc(x, k) +
                           cos(l * M_PI * y) * pow_loc(x, k);
                }
            }
        }
        else if (btype[1] == eFourierSingleMode && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                sol += sin(M_PI * y) * pow_loc(x, k) +
                       cos(M_PI * y) * pow_loc(x, k);
            }
        }
        else
        {
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        sol += pow_loc(x, k) * pow_loc(y, l) * pow_loc(z, m);
                    }
                }
            }
        }
    }
    else if (diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += k * M_PI * (cos(k * M_PI * z) - sin(k * M_PI * z));
            }
        }
        else if (btype[0] != eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += k * pow_loc(x, k - 1) * sin(M_PI * l * y)
                           + M_PI * l * pow_loc(x, k) * cos(M_PI * l * y) +
                           +k * pow_loc(x, k - 1) * cos(M_PI * l * y)
                           - M_PI * l * pow_loc(x, k) * sin(M_PI * l * y);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] != eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1) +
                           -M_PI * k * sin(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * sin(M_PI * k * x) * cos(M_PI * l * y)
                           + M_PI * k * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * sin(M_PI * k * x) * sin(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * cos(M_PI * k * x) * sin(M_PI * l * y);
                }
            }
        }
        else
        {
            NekDouble a;
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        a = k * pow_loc(x, k - 1) * pow_loc(y, l) *
                            pow_loc(z, m);
                        sol += a;
                        a = l * pow_loc(x, k) * pow_loc(y, l - 1) *
                            pow_loc(z, m);
                        sol += a;
                        a = m * pow_loc(x, k) * pow_loc(y, l) *
                            pow_loc(z, m - 1);
                        sol += a;
                    }
                }
            }
        }
    }

    return sol;
}
