///////////////////////////////////////////////////////////////////////////////
//
// File: NodalDemo.cpp
//
// For more information, please see: http://www.nektar.info
//
// The MIT License
//
// Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
// Department of Aeronautics, Imperial College London (UK), and Scientific
// Computing and Imaging Institute, University of Utah (USA).
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Description: Demo for testing functionality of StdProject
//
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include "StdDemoSupport.hpp"
#include <fstream>
#include <time.h>
#define LOGNAME_FORMAT "%Y%m%d_%H%M%S"
#define LOGNAME_SIZE 20


namespace po = boost::program_options;

NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff);

//Modification to deal with exact solution for diff. Return 1 if integer < 0.
static double pow_loc(const double val, const int i)
{
  return (i < 0) ? 1.0 : pow(val, i);
}


void  pq(
         Array<OneD,NekDouble> uhats,
         Array<OneD, Array<OneD ,NekDouble > >roots,
         Array<OneD,NekDouble> V1,
         Array<OneD,NekDouble> &pqevalxast = NullNekDouble1DArray,
         Array<OneD,NekDouble>&fvals = NullNekDouble1DArray);


//declare Do_optimize
void Do_optimize(Array<OneD, NekDouble> &uhats);

Array<OneD, Array<OneD, NekDouble> > vectoarr(vector<vector< NekDouble> > vec);


//declare find_roots, flag is 0 for confederate matrix approach
vector<vector<  NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> evalxyz = NullNekDouble1DArray, int d = 0, int flag = 0,  int sig = 0, int surfflag = 0, int surfid = 0);

// declare caller routine to find_roots
// flag = 0 -> opt_needed calls
// flag = 1 -> sphere_rot calls
Array<OneD, Array< OneD,  NekDouble> >  call_find_roots(Array<OneD, NekDouble> &uhatsall, int d = 0, Array< OneD, Array<OneD, NekDouble> >&uhatsedges =NullNekDoubleArrayofArray , Array< OneD, Array<OneD, NekDouble> >&surfaceuhats =NullNekDoubleArrayofArray ,  int flag = 0 );


//declare Opt_needed
int Opt_needed(Array<OneD, NekDouble> uhats, int flag = 0);


// for 2D elements to get uhats at edges
// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble> uhats,Array<OneD, Array<OneD, NekDouble> >&ret , int d = 0);

void derpq(Array<OneD, NekDouble> &uhats,  NekDouble &ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd);

// uhatpqd stuff: 
// called by project_edges if d = 1 is passed in project_edges
void edgederpquhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret, int modes, Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd0, Array<OneD, NekDouble> Vxyd1 = NullNekDouble1DArray , Array<OneD, NekDouble> Vxyd2 = NullNekDouble1DArray);

void deruhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble >&ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd0, Array<OneD, NekDouble> Vxyd1, Array<OneD, NekDouble> Vxyd2 = NullNekDouble1DArray, int surfflag = 0, int surfid = 0 );

//void project_surfaces( Array<OneD, NekDouble>uhats,    Array<OneD, Array<OneD, NekDouble> >&ret, int sig = 0 );

vector< vector<NekDouble> > gradient_descent(Array<OneD, NekDouble> uhats, Array<OneD, NekDouble> evalxyz,  int sig, int surfflag , int surfid = 0);


FILE *csvfile(int flag);
void WriteCSV( Array<OneD, NekDouble>  uhats, int flag = 0);


string funcdef;
// Colleague matrix
int numedges, numsurfaces;
Array<OneD, Array<OneD, NekDouble> > C;
StdExpansion *E;
StdExpansion *E3seg;
//StdExpansion *E3quad;
Array<OneD, NekDouble> qZin; //inner point grid for 2D rootfinding
Array<OneD, Array<OneD, NekDouble> > edgeptsin;
Array<OneD, NekDouble> qZinmid; //inner mid point grid for 2D rootfinding
Array<OneD, NekDouble> qWin; //inner point grid for 2D rootfinding
Array<OneD, NekDouble> qx;

Array<OneD, Array<OneD, NekDouble> > qxarr;

Array<OneD, Array<OneD, NekDouble> >qxarrquad;
Array<OneD, Array<OneD, NekDouble> > qxarrtri;
Array<OneD, Array<OneD, Array<OneD, NekDouble> > > surfcoords;
Array<OneD, NekDouble> qw;

Array<OneD, NekDouble> V;
Array<OneD, NekDouble> Vd;
//Array<OneD, NekDouble> V3;
Array<OneD, NekDouble > qWinarr;
Array<OneD, NekDouble> Vquad;

// for prism edges root finding

// edge front left (x = -1) (y = -1)
Array<OneD, NekDouble> Vxm1ym1z   ;
Array<OneD, NekDouble> Vdyxm1ym1z   ;
Array<OneD, NekDouble> Vdxxm1ym1z   ;
Array<OneD, NekDouble> Vdzxm1ym1z   ;
               
//edge front hypt (y = -1) (z = -x)
Array<OneD, NekDouble> Vym1xmz   ;
Array<OneD, NekDouble> Vdxym1xmz   ;
Array<OneD, NekDouble> Vdyym1xmz   ;
Array<OneD, NekDouble> Vdzym1xmz   ;
               
//edge front bot (y = -1) (z = -1)
Array<OneD, NekDouble> Vym1xzm1   ;
Array<OneD, NekDouble> Vdyym1xzm1   ;
Array<OneD, NekDouble> Vdxym1xzm1   ;
Array<OneD, NekDouble> Vdzym1xzm1   ;

// edge back left (y = 1), (x = -1)
Array<OneD, NekDouble> Vxm1y1z   ;
Array<OneD, NekDouble> Vdyxm1y1z   ;
Array<OneD, NekDouble> Vdxxm1y1z   ;
Array<OneD, NekDouble> Vdzxm1y1z   ;
               
//edge back hypt ( y = 1) (z = -x)
Array<OneD, NekDouble> Vy1xmz   ;
Array<OneD, NekDouble> Vdxy1xmz   ;
Array<OneD, NekDouble> Vdyy1xmz   ;
Array<OneD, NekDouble> Vdzy1xmz   ;
               
//edge back bot (y = 1) (z = -1))
Array<OneD, NekDouble> Vy1xzm1   ;
Array<OneD, NekDouble> Vdyy1xzm1   ;
Array<OneD, NekDouble> Vdxy1xzm1   ;
Array<OneD, NekDouble> Vdzy1xzm1   ;

// edge left bot (z = -1), (x = -1)
Array<OneD, NekDouble> Vxm1yzm1   ;
Array<OneD, NekDouble> Vdyxm1yzm1   ;
Array<OneD, NekDouble> Vdxxm1yzm1   ;
Array<OneD, NekDouble> Vdzxm1yzm1   ;
                
//edge left top (x = -1), (z = 1))
Array<OneD, NekDouble> Vxm1yz1   ;
Array<OneD, NekDouble> Vdyxm1yz1   ;
Array<OneD, NekDouble> Vdxxm1yz1   ;
Array<OneD, NekDouble> Vdzxm1yz1   ;
               
//edge right bot ( z = -1) (x = 1)
Array<OneD, NekDouble> Vx1yzm1   ;
Array<OneD, NekDouble> Vdyx1yzm1   ;
Array<OneD, NekDouble> Vdxx1yzm1   ;
Array<OneD, NekDouble> Vdzx1yzm1   ;
 
//surface bot z = -1
Array<OneD, NekDouble>Vxyzm1 ;


//surface left x = -1
Array<OneD, NekDouble>Vxm1yz ;


//surface hypt x+z = 0
Array<OneD, NekDouble>Vxzmy ;


//surface front y = -1
Array<OneD, NekDouble>Vxym1z ;

//surface back y = 1
Array<OneD, NekDouble>Vxy1z ;
  

int dimension ;
Array<OneD, NekDouble > interioreval3d;
Array<OneD, Array<OneD, NekDouble> > testcoord3d; 
Array<OneD, Array<OneD, NekDouble> > testcoord2dquad; 
NekDouble iterGD, secarg, startval, startcoordx, startcoordy, startcoordz;
            
DemoSupport demo;

int main(int argc, char *argv[])
{
  demo.GetOptions().add_options()("optm,z", "positivity preserving optimizer");
  demo.ParseArguments(argc, argv);
    
  po::variables_map vm = demo.GetVariableMap();

  //only for 1D
       
  E = demo.CreateStdExpansion();
  if (E == nullptr)
    {
      return 1;
    }
  dimension = E->GetShapeDimension();
  if(dimension < 3 )
    {
      cout<<"\n dimension should be 3, try using StdProjectPositivityPres1D or StdProjectPositivityPres2D for other dimensions\n\n";
      exit(0);
    }

  std::vector<int> order;
  std::vector<BasisType> btype(3, eNoBasisType);
  LibUtilities::ShapeType stype = E->DetShapeType();
  LibUtilities::PointsType pointsTypeCheb = LibUtilities::eGaussGaussChebyshev;    

  for (int i = 0; i < dimension; ++i)
    {
      btype[i] = E->GetBasisType(i);
      order.push_back(E->GetBasisNumModes(i));
    }

  C = demo.formConf((dimension)*pow(3*order[0]+1,2));
    
  switch(E->DetShapeType())
    {
    case LibUtilities::eSegment:
        
      numedges = 1;
      numsurfaces = 0;
      break;
    

    case LibUtilities::eTriangle:
        
      numedges = 3;
      numsurfaces = 0;
      break;

    case LibUtilities::ePrism:
        
      numedges = 9;
      numsurfaces = 5;
      break;

    
    case LibUtilities::eQuadrilateral:
        
      numedges = 4;
      numsurfaces = 1;
      break;

    case LibUtilities::eHexahedron:
        
      numedges = 12;
      numsurfaces = 6;
      break;
        

    
    default: cout<<"\n unknown shape type\n\n";exit(0);
    
    }
    
  const auto totPoints = (unsigned) E->GetTotPoints();

  Array<OneD, NekDouble> x = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> y = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> z = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> dx = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> dy = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> dz = Array<OneD, NekDouble>(totPoints);
  Array<OneD, NekDouble> sol = Array<OneD, NekDouble>(totPoints);


  switch (dimension)
    {
    case 1:
      {
	E->GetCoords(x);
	break;
      }

    case 2:
      {
	E->GetCoords(x, y);
	break;
      }

    case 3:
      {
	E->GetCoords(x, y, z);
	break;
      }
    default:
      break;
    }

  //get solution array
  for (int i = 0; i < totPoints; ++i)
    {
      if(dimension ==3) //hex
        {
	  sol[i] = sin(x[i])*sin(y[i])*sin(z[i]);//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.5;//sin(x[i])*sin(y[i])*sin(z[i]);///sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(x[i])*sin(y[i])*sin(z[i]);//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(x[i])*sin(y[i])*sin(z[i]);//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(x[i])*sin(y[i])*sin(z[i]);//sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);//sin(x[i])*sin(y[i])*sin(z[i])+0.1;//sin(x[i])*sin(y[i])*sin(z[i]);// +0.1;//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(x[i])*sin(y[i])*sin(z[i])+0.1;//sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);//sin(x[i])*sin(y[i])*sin(z[i]);//sin(x[i])*sin(y[i])*sin(z[i]) +0.1;//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);//sin(x[i])*sin(y[i])*sin(z[i]);//sin(x[i])*sin(y[i])*sin(z[i]) ;//sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);//sin(x[i])*sin(y[i])*sin(z[i]);//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2;//sin(2*M_PI*x[i])*sin(2*M_PI*y[i])*sin(2*M_PI*z[i])-2;//sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);//sin(3*x[i])*sin(3*y[i])*sin(3*z[i])+0.1;
	  funcdef ="sin(x)*sin(y)*sin(z)";//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.5";//sin(x[i])*sin(y[i])*sin(z[i]);";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])";//"sin(x[i])*sin(y[i])*sin(z[i])+0.1";//"sin(x[i])*sin(y[i])*sin(z[i]) ";//+0.1";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(x[i])*sin(y[i])*sin(z[i])+0.1";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(x[i])*sin(y[i])*sin(z[i]) +0.1";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])";//"sin(x[i])*sin(y[i])*sin(z[i]) ";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])+0.1";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.9";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(x[i])*sin(y[i])*sin(z[i]);";//sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.9";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])+0.1;";//"sin(x[i])*sin(y[i])*sin(z[i];";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.9";//"sin(2*M_PI*x[i])*sin(2*M_PI*y[i])*sin(2*M_PI*z[i])-2 ";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.9";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])+0.1";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])+0.5";//"sin(x[i])*sin(y[i])*sin(z[i])";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";//"sin(2*M_PI*x[i])*sin(2*M_PI*y[i])*sin(2*M_PI*z[i])-2";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i]);";// "sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])  -2";//"sin(3*x[i])*sin(3*y[i])*sin(3*z[i])+0.1";//"sin(M_PI*x[i])*sin(M_PI*y[i])*sin(M_PI*z[i])-2";// -  exp(-1) + 1.37";
	}
    }

  Array<OneD, NekDouble> phys(totPoints);
  Array<OneD, NekDouble> coeffs((unsigned) E->GetNcoeffs());
    
  //Project onto expansion
  E->FwdTrans(sol, coeffs);

  //Backward transform solution to get projected values
  E->BwdTrans(coeffs, phys);
    
  if (vm.count("optm"))
    {
            

      int dimension = E->GetShapeDimension(); 
      Array<OneD, Array<OneD, NekDouble> > qxarr(dimension);
      //qx = E->GetBasis(0)->GetZ();
      //qw = E->GetBasis(0)->GetW();            
      vector<LibUtilities::BasisKey> tmpBasisKey = demo.GetBasisKey();       
      LibUtilities::PointsKey pkeycheb(E->GetBasis(0)->GetNumPoints(), pointsTypeCheb);

      LibUtilities::BasisKey bkeycheb(LibUtilities::eChebyshev, 3*(E->GetBasis(0)->GetNumModes()),  pkeycheb);
        
      E3seg = new StdSegExp(bkeycheb);
        
      if (E3seg == nullptr)
        {
	  return 1;
        }
      // V3 is required by edge root finding (even for 1D)
      //V3 = Array<OneD, NekDouble>(E3seg->GetTotPoints()*E3seg->GetNcoeffs());
        
      qxarr[0] = E->GetBasis(0)->GetZ();
        
        
      //        E3seg->PhysEvalBasisGrad(qxarr, V3, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray );
        
      if(dimension > 1 )
        {

        
	  // populate edge root finding matrices for quadrilateral
	  LibUtilities::PointsKey  quadPointsKeyin  (order[0], pointsTypeCheb);
	  // for gradient descent
	  qZin = (LibUtilities::PointsManager()[quadPointsKeyin ])->GetZ();
	  int sz = pow(qZin.size(),2);;
	  int szmid = pow(qZin.size()-1,2);
	  qZinmid = Array<OneD,NekDouble>(qZin.size()-1);
            
	  for(int i = 0; i <qZinmid.size(); i++)
            {
	      qZinmid[i] = (qZin[i]+qZin[i+1])/2;
            }


	  testcoord2dquad = Array<OneD, Array<OneD, NekDouble> > (2); 
	  for(int k = 0; k < qxarr.size(); k++ )
	    qxarr[k] = Array<OneD, NekDouble> (E->GetBasis(0)->GetNumPoints());//demo.GetCoords(E);
            
	  int ctsz2dquad = 0;
             
	  for(int ii = 0; ii < 2; ++ii)
            {
	      testcoord2dquad[ii] = Array<OneD, NekDouble>(sz+szmid);          }
	  for(int ii = 0; ii < qZin.size(); ++ii)
            {
                
	      for(int jj = 0; jj < qZin.size(); ++jj)
                {
		  testcoord2dquad[0][ctsz2dquad] = qZin[ii];
		  testcoord2dquad[1][ctsz2dquad] = qZin[jj];
		  ctsz2dquad++;

                }

            }            
	  // add midpt grid
	  for(int ii = 0; ii < qZinmid.size(); ++ii)
            {
	      for(int jj = 0; jj < qZinmid.size(); ++jj)
                {
                
		  testcoord2dquad[0][ctsz2dquad] = qZinmid[ii];
		  testcoord2dquad[1][ctsz2dquad] = qZinmid[jj];
		  ctsz2dquad++;
                    

                }
                

            }         

	  LibUtilities::BasisKey bkeychebtmp(LibUtilities::eChebyshev, tmpBasisKey[0].GetNumModes(),  pkeycheb);
	  //            E3quad = new StdQuadExp(bkeychebtmp,bkeychebtmp);
	  //qxarrquad = demo.GetCoords(E3quad);

	  // Vquad = Array<OneD, NekDouble>(E3quad->GetTotPoints()*E3quad->GetNcoeffs());


	  // E3quad->PhysEvalBasisGrad(qxarrquad, Vquad, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
           
            
	  sz = pow((qZin.size()+qZinmid.size()),3);;

	  Array<OneD, Array<OneD, NekDouble> >testcoord3dtemp  (dimension); 
	  testcoord3d = Array<OneD, Array<OneD, NekDouble> > (dimension); 
	  for(int ii = 0; ii < 3; ++ii)
            {
	      testcoord3dtemp[ii] = Array<OneD, NekDouble>(sz);
            }
	  int ctsz = 0;
	  for(int ii = 0; ii < qZin.size(); ++ii)
            {
                    
	      for(int jj = 0; jj < qZin.size(); ++jj)
                {

		  for(int kk = 0; kk < qZin.size(); ++kk)
                    {
		      if(qZin[ii] + qZin[kk] <=0) 
                        {
			  testcoord3dtemp[0][ctsz] = qZin[ii];
			  testcoord3dtemp[1][ctsz] = qZin[jj];
			  testcoord3dtemp[2][ctsz] = qZin[kk];
			  ctsz++;
                        }
                    }
                }
            }

	  for(int ii = 0; ii < qZinmid.size(); ++ii)
            {
                    
	      for(int jj = 0; jj < qZinmid.size(); ++jj)
                {

		  for(int kk = 0; kk < qZinmid.size(); ++kk)
                    {
		      if(qZinmid[ii] + qZinmid[kk] <=0) 
                        {
			  testcoord3dtemp[0][ctsz] = qZinmid[ii];
			  testcoord3dtemp[1][ctsz] = qZinmid[jj];
			  testcoord3dtemp[2][ctsz] = qZinmid[kk];
			  ctsz++;
                        }
                    }
                }
            }

	  for(int ii = 0; ii < dimension; ++ii)
            {
	      testcoord3d[ii] = Array<OneD, NekDouble>(ctsz);
	      Vmath::Vcopy(ctsz, &testcoord3dtemp[ii][0], 1, &testcoord3d[ii][0], 1);

            }
	  qxarr = demo.GetCoords(E);

                
	  interioreval3d = Array<OneD, NekDouble >(E->GetNcoeffs()*testcoord3d[0].size());

                
	  E->PhysEvalBasisGrad(testcoord3d, interioreval3d, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
            

            
	  if(numedges == 9) //prism
            {
	      //we need qzin + qzinmid as input points
	      Array<OneD, NekDouble> edgexyztemp =   E3seg->GetBasis(0)->GetZ();

	      int totszedges1d =  edgexyztemp.size()*(E->GetNcoeffs());//E->GetNcoeffs()*(E->GetBasis(0)->GetNumPoints());//(qZin.size()+qZinmid.size())*E->GetNcoeffs(); 
	      //                Array<OneD, Array<OneD, NekDouble> >  edgeptsintemp(dimension);
               
	      edgeptsin = Array<OneD, Array<OneD, NekDouble> >(dimension);         
	      for(int p = 0; p < dimension; p++)
                {
		  edgeptsin[p] =   Array<OneD, NekDouble>(edgexyztemp);            
                }
	      // edge front left (x = -1) (y = -1)
	      Vxm1ym1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdxxm1ym1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdyxm1ym1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdzxm1ym1z = Array<OneD, NekDouble>(totszedges1d);
	      edgeptsin[0] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);
	      edgeptsin[1] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);

	      E->PhysEvalBasisGrad(edgeptsin, Vxm1ym1z, Vdxxm1ym1z, Vdyxm1ym1z, Vdzxm1ym1z);  
                
	      //edge front hypt (y = -1) (z + x = 0)
	      Vym1xmz = Array<OneD, NekDouble>(totszedges1d);
	      Vdxym1xmz = Array<OneD, NekDouble>(totszedges1d);
	      Vdyym1xmz = Array<OneD, NekDouble>(totszedges1d);
	      Vdzym1xmz = Array<OneD, NekDouble>(totszedges1d);
	      Vmath::Smul(edgeptsin[0].size(), -1.0, &edgeptsin[2][0], 1, &edgeptsin[0][0], 1);

	      E->PhysEvalBasisGrad(edgeptsin,Vym1xmz, Vdxym1xmz,Vdyym1xmz,Vdzym1xmz);  

                
	      //edge front bot (y = -1) (z = -1)
	      Vym1xzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdxym1xzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdyym1xzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdzym1xzm1 = Array<OneD, NekDouble>(totszedges1d);
	      edgeptsin[0] = edgexyztemp;
	      edgeptsin[2] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);           
            
	      E->PhysEvalBasisGrad(edgeptsin, Vym1xzm1, Vdxym1xzm1, Vdyym1xzm1, Vdzym1xzm1);  

	      // edge back left (y = 1), (x = -1)
	      Vxm1y1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdxxm1y1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdyxm1y1z = Array<OneD, NekDouble>(totszedges1d);
	      Vdzxm1y1z = Array<OneD, NekDouble>(totszedges1d);

	      edgeptsin[2] = edgexyztemp;
	      edgeptsin[0] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);
	      edgeptsin[1] = Array<OneD, NekDouble>(edgeptsin[0].size(), 1.0);           
	      E->PhysEvalBasisGrad(edgeptsin,Vxm1y1z, Vdxxm1y1z, Vdyxm1y1z, Vdzxm1y1z);  

	      //edge back hypt ( y = 1) (z +x = 0)
	      Vy1xmz = Array<OneD, NekDouble>(totszedges1d);
	      Vdxy1xmz = Array<OneD, NekDouble>(totszedges1d)   ;
	      Vdyy1xmz = Array<OneD, NekDouble>(totszedges1d)    ;
	      Vdzy1xmz =Array<OneD, NekDouble>(totszedges1d)    ;

	      Vmath::Smul(edgeptsin[0].size(), -1.0, &edgeptsin[2][0], 1, &edgeptsin[0][0], 1);
	      E->PhysEvalBasisGrad(edgeptsin,Vy1xmz, Vdxy1xmz, Vdyy1xmz, Vdzy1xmz);  
                
	      //edge back bot (y = 1) (z = -1))
	      Vy1xzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdyy1xzm1 = Array<OneD, NekDouble>(totszedges1d)   ;
	      Vdxy1xzm1   = Array<OneD, NekDouble>(totszedges1d);
	      Vdzy1xzm1 = Array<OneD, NekDouble>  (totszedges1d) ;
	      edgeptsin[0] = edgexyztemp;
	      edgeptsin[2] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);
	      E->PhysEvalBasisGrad(edgeptsin,Vy1xzm1, Vdxy1xzm1, Vdyy1xzm1, Vdzy1xzm1 );  

	      // edge left bot (z = -1), (x = -1)
	      Vxm1yzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdyxm1yzm1 = Array<OneD, NekDouble>(totszedges1d)   ;
	      Vdxxm1yzm1 = Array<OneD, NekDouble>(totszedges1d)   ;
	      Vdzxm1yzm1 = Array<OneD, NekDouble>(totszedges1d)   ;
                
	      edgeptsin[1] = edgexyztemp;
	      edgeptsin[0] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);
	      edgeptsin[2] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);
	      E->PhysEvalBasisGrad(edgeptsin,Vxm1yzm1, Vdxxm1yzm1, Vdyxm1yzm1, Vdzxm1yzm1);  
                
	      //edge left top (x = -1), (z = 1))
	      Vxm1yz1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdyxm1yz1 = Array<OneD, NekDouble>  (totszedges1d) ;
	      Vdxxm1yz1 = Array<OneD, NekDouble >(totszedges1d)  ;
	      Vdzxm1yz1 = Array<OneD, NekDouble>(totszedges1d)   ;

	      edgeptsin[2] = Array<OneD, NekDouble>(edgeptsin[0].size(), 1.0);           
	      E->PhysEvalBasisGrad(edgeptsin,Vxm1yz1,Vdxxm1yz1, Vdyxm1yz1, Vdzxm1yz1);  
                
	      //edge right bot ( z = -1) (x = 1)
	      Vx1yzm1 = Array<OneD, NekDouble>(totszedges1d);
	      Vdyx1yzm1 =Array<OneD, NekDouble>(totszedges1d);
                
	      Vdxx1yzm1= Array<OneD, NekDouble>(totszedges1d);
                
	      Vdzx1yzm1  = Array<OneD, NekDouble>(totszedges1d);
                

	      edgeptsin[1] = edgexyztemp;
	      edgeptsin[0] = Array<OneD, NekDouble>(edgeptsin[0].size(), 1.0);           
	      edgeptsin[2] = Array<OneD, NekDouble>(edgeptsin[0].size(), -1.0);           
	      E->PhysEvalBasisGrad(edgeptsin,Vx1yzm1, Vdxx1yzm1, Vdyx1yzm1, Vdzx1yzm1);   
	      //cout<<"\n 1\n\n";
	    }
	  if(numsurfaces == 5) // prism
            {
	      surfcoords = Array<OneD, Array<OneD, Array<OneD, NekDouble> > >(numsurfaces);
	      //we need convolution of qzin + qzinmid as input points
	      int totszsurf2d = (testcoord2dquad[0].size())*E->GetNcoeffs();
	      //	      cout<<"\n 1"<<testcoord2dquad.size()<<"\n\n";            

                
	      Array<OneD, Array<OneD, NekDouble> > surfptsin(dimension), surfptsintemp(dimension);
	      for(int k = 0; k < dimension-1; k++)
                {
		  surfptsin[k] = Array<OneD, NekDouble>(testcoord2dquad[k]);
		  surfptsintemp[k] = Array<OneD, NekDouble>(testcoord2dquad[k]);
                }
	      //cout<<"\n 1\n\n";            

	      surfptsin[dimension-1] = Array<OneD, NekDouble>(testcoord2dquad[0].size()); 
	      surfptsintemp[dimension-1] = Array<OneD, NekDouble>(testcoord2dquad[0].size()); 

	      //surface bot z = -1
	      Vxyzm1 =  Array<OneD, NekDouble>(totszsurf2d);
	      surfptsintemp[2] = Array<OneD, NekDouble>(surfptsin[0].size(), -1.0);
	      surfcoords[0] = surfptsintemp;

	      E->PhysEvalBasisGrad(surfptsintemp,Vxyzm1, NullNekDouble1DArray,NullNekDouble1DArray,NullNekDouble1DArray);   


	      //surface hypt x+z = 0
	      Vxzmy =  Array<OneD, NekDouble>(totszsurf2d);
	      Vmath::Smul(surfptsin[0].size(), -1.0, &surfptsin[0][0], 1, &surfptsintemp[2][0], 1);
	      surfptsintemp[0] = surfptsin[0];
	      surfptsintemp[1] = surfptsin[1];
	      surfcoords[1] = surfptsintemp;

	      E->PhysEvalBasisGrad(surfptsintemp,Vxzmy,NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);   
                
	      //surface left x = -1
	      Vxm1yz =  Array<OneD, NekDouble>(totszsurf2d);
	      surfptsintemp[0] = Array<OneD, NekDouble>(surfptsin[0].size(), -1.0);
	      surfptsintemp[1] = surfptsin[0];
	      surfptsintemp[2] = surfptsin[1];
	      surfcoords[2] = surfptsintemp;
                
	      E->PhysEvalBasisGrad(surfptsintemp,Vxm1yz, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);   
                
	      //surface front y = -1
	      Vxym1z =  Array<OneD, NekDouble>(totszsurf2d);
	      surfptsintemp[1] = surfptsintemp[0];
	      surfptsintemp[0] = surfptsin[0];
	      surfptsintemp[2] = surfptsin[1];
	      surfcoords[3] = surfptsintemp;

	      E->PhysEvalBasisGrad(surfptsintemp,Vxym1z, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);   
                
	      //surface back y = 1
	      Vxy1z =  Array<OneD, NekDouble>(totszsurf2d);
                
	      surfptsintemp[1] = Array<OneD, NekDouble>(surfptsin[0].size(), 1.0);
	      surfcoords[4] = surfptsintemp;

	      E->PhysEvalBasisGrad(surfptsintemp,Vxy1z, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
            }
        }

      if(Opt_needed(coeffs))
        {

	  cout<<"\n need optimization";
	  WriteCSV(coeffs);

	  Do_optimize(coeffs);
            
	  cout<<"\n doopt done\n verifying...\n";
	  if(Opt_needed(coeffs,1 ))
            {
	      cout<<"func="<<funcdef;

	      cout<<"\n fail\n\n";
	      exit(0);
            }
	  else
            {
	      cout<<"func="<<funcdef;
	      cout<<"\n pass\n\n";
	      WriteCSV(coeffs, 1);

	      sol = phys;
            }
        }
      else{
	cout<<"\n optimizer no need\n\n";
      }
      //Backward transform solution to get projected values
      E->BwdTrans(coeffs, phys);

    }

  //Calculate L_inf & L_2 error
  cout << "L infinity error: \t" << E->Linf(phys, sol) << endl;
  if (stype != ePoint)
    {
      cout << "L 2 error: \t \t \t" << E->L2(phys, sol) << endl;
    }

  if (!vm.count("diff") && stype != ePoint)
    {
      //Evaluate solution at x = y = 0 and print error
      Array<OneD, NekDouble> t = Array<OneD, NekDouble>(3);
      t[0] = -0.5;
      t[1] = -0.25;
      t[2] = -0.3;
      sol[0] = Shape_sol(t[0], t[1], t[2], order, btype, stype, false);

      NekDouble nsol = E->PhysEvaluate(t, phys);

      cout << "Error at x = (";
      for (int i = 0; i < dimension; ++i)
        {
	  cout << t[i] << ", ";
        }
      cout << "\b\b): " << nsol - sol[0] << endl;
    }

  // Calculate integral of known function to test different quadrature
  // distributions on each element.
  for (int i = 0; i < totPoints; ++i)
    {
      sol[i] = dimension == 1 ? exp(x[i]) : dimension == 2 ?
	exp(x[i]) * sin(y[i]) : exp(x[i] + y[i] + z[i]);
    }

  NekDouble exact = 0.0;
  switch(stype)
    {
    case eSegment:
      exact = M_E - 1.0 / M_E;
      break;
    case eTriangle:
      exact = -0.5 * (sin(1.0) + cos(1.0) + M_E * M_E *
		      (sin(1.0) - cos(1.0))) / M_E;
      break;
    case eQuadrilateral:
      exact = 2.0 * (M_E - 1.0 / M_E) * sin(1.0);
      break;
    case eTetrahedron:
      exact = 1.0 / M_E - 1.0 / M_E / M_E / M_E;
      break;
    case ePrism:
      exact = M_E - 1.0 / M_E / M_E / M_E;
      break;
    case ePyramid:
      exact = - 1.0 / M_E / M_E / M_E - 4.0 / M_E + M_E;
      break;
    case eHexahedron:
      exact = pow((M_E * M_E - 1.0) / M_E, 3.0);
      break;
    default:
      ASSERTL0(false, "Exact solution not known.");
      break;
    }
  std::cout << "Integral error: " << fabs(exact - E->Integral(sol))
	    << std::endl;

  return 0;
}

Array<OneD, Array<OneD, NekDouble> > vectoarr(vector<vector <NekDouble> > vec)
{
  //    cout<<"\n vec size = "<<vec.size()<<" "<<vec[0].size()<<"\n";
  Array<OneD, Array<OneD, NekDouble> > ret(vec.size());
  for (int k = 0; k < vec.size(); k++)
    {
      ret[k ] = Array<OneD, NekDouble>(vec[k].size(), vec[k].data());
      // for(int p = 0; p < vec[k].size(); p++)
      // {
      //     ret[k][p] = vec[k][p];
      // }
    }
  return ret;
}


// void project_surfaces( Array<OneD, NekDouble>uhats,    Array<OneD, Array<OneD, NekDouble> >&ret, int sig)
// {
//     boost::ignore_unused(sig);
//     //    int modes = E->GetNcoeffs();
//     int modes2Dquad = E3quad->GetNcoeffs();
    
//     // if(sig == 0)
//     // {
//     //     for(int k= 0; k < numsurfaces; k++)
//     //     {
//     //         ret[k] = Array<OneD, NekDouble>(modes);
            
//     //     } 
//     // }
//     // else if(sig == 1)
//     // {
//     //     for(int k= 0; k < numsurfaces; k++)
//     //     {
//     //         ret[k] = Array<OneD, NekDouble>(modes1D);
            
//     //     } 
        
//     // }
    
//     if(numsurfaces == 5) // prism
//     {
//         //bot surface  z = -1 -> quad so last arg is by default 0
//         ret[0] = Array<OneD, NekDouble>(modes2Dquad);
//         deruhats(uhats, ret[0], Vxyzm1, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray,1);
//         //surface hypt x+z = 0 -> quad so last arg is by default 0
//         ret[1] = Array<OneD, NekDouble>(modes2Dquad);
//         deruhats(uhats, ret[1], Vxzmy , NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray,1);
//         //surface left x = -1 ->quad so last arg is by default 0
//         ret[2] = Array<OneD, NekDouble>(modes2Dquad);
//         deruhats(uhats, ret[2], Vxm1yz, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray,1 );     
//         //front surface y = -1 -> tri, so last arg is 1 
//         // ret[3] = Array<OneD, NekDouble>(modes2Dtri);
//         // deruhats(uhats, ret[3], Vxym1z, Vdxxym1z, Vdyxym1z, Vdzxym1z,1, 1);
//         // //surface back y = 1 -> tri, so last arg is 1 
//         // ret[4] = Array<OneD, NekDouble>(modes2Dtri);
//         // deruhats(uhats, ret[4], Vxy1z, Vdxxy1z, Vdyxy1z, Vdzxy1z, 1, 1);
        
//     }
// }


// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>uhats,    Array<OneD, Array<OneD, NekDouble> >&ret , int d)
{
  //    int modes = E->GetNcoeffs();
  //    int modes1D = (3*(E->GetBasis(0)->GetNumModes()-1));//3*(E->GetBasis(0)->GetNumModes()-1);
  // In case of tri:
  // hypotenuse = 2, bot = 1, left = 2
    
  // assert d = 0 or 1
  int modes =  (3*(E->GetBasis(0)->GetNumModes()));
  if(d == 0)
    {   
      for(int k= 0; k < numedges; k++)
        {
	  ret[k] = Array<OneD, NekDouble>(modes);
        }
    }
  if(numedges == 9) // hex
    {

      if(d == 1)
        {

	  // edge front left (x = -1) (y = -1)
	  edgederpquhats(uhats, ret[0], E->GetNcoeffs(),  Vxm1ym1z, Vdxxm1ym1z, Vdyxm1ym1z, Vdzxm1ym1z);
                        
	  //edge front hypt (y = -1) (z + x = 0)
	  edgederpquhats(uhats, ret[1], E->GetNcoeffs(), Vym1xmz, Vdxym1xmz, Vdyym1xmz, Vdzym1xmz);
        
      
            
	  //edge front bot (y = -1) (z = -1)
	  edgederpquhats(uhats, ret[2], E->GetNcoeffs(),  Vym1xzm1, Vdxym1xzm1, Vdyym1xzm1, Vdzym1xzm1);
    
     
	  // edge back left (y = 1), (x = -1)
	  edgederpquhats(uhats, ret[3], E->GetNcoeffs(), Vxm1y1z, Vdxxm1y1z, Vdyxm1y1z, Vdzxm1y1z);
     
	  //edge back hypt ( y = 1) (z +x = 0)
	  edgederpquhats(uhats, ret[4], E->GetNcoeffs(),  Vy1xmz, Vdxy1xmz, Vdyy1xmz, Vdzy1xmz);
   
	  //edge back bot (y = 1) (z = -1))
	  edgederpquhats(uhats, ret[5], E->GetNcoeffs(),  Vy1xzm1, Vdxy1xzm1, Vdyy1xzm1, Vdzy1xzm1);
            
	  // edge left bot (z = -1), (x = -1)
	  edgederpquhats(uhats, ret[6], E->GetNcoeffs(), Vxm1yzm1, Vdxxm1yzm1, Vdyxm1yzm1, Vdzxm1yzm1);
            
	  //edge left top (x = -1), (z = 1))
	  edgederpquhats(uhats, ret[7], E->GetNcoeffs(),   Vxm1yz1,Vdxxm1yz1, Vdyxm1yz1, Vdzxm1yz1);
            
	  //edge right bot ( z = -1) (x = 1)
	  edgederpquhats(uhats, ret[8], E->GetNcoeffs(),   Vx1yzm1, Vdxx1yzm1, Vdyx1yzm1, Vdzx1yzm1);
        
     
        }
      else if( d == 0)
        {
	  // edge front left (x = -1) (y = -1)
	  deruhats(uhats, ret[0], Vxm1ym1z, Vdxxm1ym1z, Vdyxm1ym1z,Vdzxm1ym1z );
        
	  //edge front hypt (y = -1) (z + x = 0)
	  deruhats(uhats, ret[1],Vym1xmz, Vdxym1xmz, Vdyym1xmz, Vdzym1xmz);
            
	  //edge front bot (y = -1) (z = -1)
	  deruhats(uhats, ret[2],  Vym1xzm1, Vdxym1xzm1, Vdyym1xzm1, Vdzym1xzm1);
            
	  // edge back left (y = 1), (x = -1)
	  deruhats(uhats, ret[3],Vxm1y1z, Vdxxm1y1z, Vdyxm1y1z, Vdzxm1y1z);
	  //edge back hypt ( y = 1) (z +x = 0)
	  deruhats(uhats, ret[4], Vy1xmz, Vdxy1xmz, Vdyy1xmz, Vdzy1xmz);
                   
	  //edge back bot (y = 1) (z = -1))
	  deruhats(uhats, ret[5], Vy1xzm1, Vdxy1xzm1, Vdyy1xzm1, Vdzy1xzm1);
            
                        
	  // edge left bot (z = -1), (x = -1)
	  deruhats(uhats, ret[6],Vxm1yzm1, Vdxxm1yzm1, Vdyxm1yzm1, Vdzxm1yzm1);
            
	  //edge left top (x = -1), (z = 1))
	  deruhats(uhats, ret[7],  Vxm1yz1,Vdxxm1yz1, Vdyxm1yz1, Vdzxm1yz1);
	  //edge right bot ( z = -1) (x = 1)
	  deruhats(uhats, ret[8],  Vx1yzm1, Vdxx1yzm1, Vdyx1yzm1, Vdzx1yzm1);
              


        }
    }
   
}

FILE *csvfile(int flag)
{
  static char name[LOGNAME_SIZE];
  char fullname[] = "Prism_";//[LOGNAME_SIZE+4];
  time_t now = time(0);
  strftime(name, sizeof(name), LOGNAME_FORMAT, localtime(&now));
  char * newArray = new char[std::strlen(fullname)+std::strlen(name)+10];
  std::strcpy(newArray,fullname);
  std::strcat(newArray,name);
  char integer_string[7];
  sprintf(integer_string, "_%d.csv", flag);
  std::strcat(newArray,integer_string);
  cout<<"\n"<< newArray<<"\n\n";
  return fopen(newArray, "w");
}

void WriteCSV(Array<OneD, NekDouble> uhats, int flag)
{

  // if flag == 0, before opt
  // if flag == 1, after opt
  FILE *file = csvfile(flag);
  Array<OneD, NekDouble >  interioreval3d = Array<OneD, NekDouble >(E->GetNcoeffs()*testcoord3d[0].size());

  E->PhysEvalBasisGrad(testcoord3d, interioreval3d, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
  int uhatstot = uhats.size();
  int totpts = testcoord3d[0].size();
  Array<OneD, NekDouble> temp(uhatstot);
  for(int i = 0; i<totpts; i++)
    {
      Vmath::Vmul(uhatstot, &interioreval3d[i], totpts, &uhats[0], 1, &temp[0], 1);
      NekDouble v = Vmath::Vsum(uhatstot, temp, 1);
      string s = std::to_string(testcoord3d[0][i])+","+std::to_string(testcoord3d[1][i])+","+std::to_string(testcoord3d[2][i])+","+std::to_string(v)+"\n";
      const char* c = s.c_str();
      fprintf (file, c); 
    }
  fclose(file);
}


void deruhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  Array<OneD, NekDouble> Vxyz, Array<OneD, NekDouble> Vdxyz, Array<OneD, NekDouble> Vxdyz, Array<OneD, NekDouble> Vxydz, int surfflag, int surfid)
{
  boost::ignore_unused(Vdxyz, Vxydz , Vxdyz, Vxyz, surfflag, surfid);
  int modes = uhats.size();
  NekDouble v1;
  if(surfflag == 1)
    {
      //        StdExpansion *tempE;

      // if(surfid == 0)//quad
      // {
      //     tempE = E3quad;
      // }
      // else //tri
      // {
      //     tempE = E3tri;
      // }
      // int totpts = E3quad->GetTotPoints(); //E->GetBasis(0)->GetNumPoints();
      // Array<OneD, NekDouble> vals(totpts);    
      // Array<OneD,  NekDouble > temp = Array<OneD, NekDouble> (modes); 
      // //Vxyz*uhats -> project to -> E3quad
      // for(int k = 0; k < totpts; k++)
      // {    
      //     Vmath::Vmul(modes, &Vxyz[k], totpts, &uhats[0], 1, &temp[0], 1);

      //     vals[k]  = Vmath::Vsum(modes, temp, 1);
      // }

      // E3quad->MultiplyByStdQuadratureMetric(vals,
      //                                  vals);
      // for(int i = 0; i<ret.size(); i++)
      // {   

      //     Vmath::Vmul(totpts, &Vquad[i], ret.size(), &vals[0], 1, &vals[0], 1);
      //     ret[i] = Vmath::Vsum(totpts, vals, 1);  

      // }
      cout<<"\n error! it should never be 1\n\n";
      exit(0);

    }
  else if(surfflag == 0)
    {
      int totpts =  E3seg->GetTotPoints();
      Array<OneD, NekDouble> temp(uhats.size()), vals(totpts);//, hold(totpts);
      for(int k = 0; k < totpts; k++)
        {    
	  // Vmath::Vmul(uhats.size(), &Vdxyz[k], totpts, &uhats[0], 1, &temp[0], 1);
	  // v1  = Vmath::Vsum(modes, temp, 1);
	  // Vmath::Vmul(uhats.size(), &Vxdyz[k], totpts, &uhats[0], 1, &temp[0], 1);
	  // v1  = v1 + Vmath::Vsum(modes, temp, 1);  
            
            
	  Vmath::Vmul(uhats.size(), &Vxyz[k], totpts, &uhats[0], 1, &temp[0], 1);

	  v1 = Vmath::Vsum(modes, temp, 1);
	  vals[k] = v1;
        }    
        
      // Vmath::Vmul(vals.size(), vals, 1, qw, 1, vals, 1);        
        
      // for(int i = 0; i<ret.size(); i++)
      // {
            
      //     Vmath::Vmul(totpts, &V3[i], ret.size(), &vals[0], 1, &hold[0], 1);
      //     ret[i] = Vmath::Vsum(vals.size(), hold, 1);
      // }
      E3seg->FwdTrans(vals,ret);
    }
}
    


void edgederpquhats(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  int modes,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd0, Array<OneD, NekDouble> Vxyd1, Array<OneD, NekDouble> Vxyd2)
{
  int uhatstot = uhats.size();
  int totpts = edgeptsin[0].size();//E3seg->GetTotPoints();
  Array<OneD, NekDouble> temp(totpts), temp2(modes), temp3(uhatstot);
  Array<OneD, NekDouble> pqeval(totpts);
  NekDouble v1, v2;
  //for(int d = 0; d < dimension; d++)
  //{
  for(int i = 0; i<totpts; i++)
    {
      Vmath::Vmul(modes, &Vxy[0]+i, totpts, &Vxyd0[0]+i, totpts, &temp2[0], 1);
      v1  = Vmath::Vsum(modes, temp2, 1); 
      Vmath::Vmul(uhatstot, &Vxy[i], totpts, &uhats[0], 1, &temp3[0], 1);

      v2  = Vmath::Vsum(uhatstot, temp3, 1);  

      v1 = v2*v1;

      // At this point,                 

      // v1 = (sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) for 1 point

      // calculate (sum(Vxm1.*Vxm1, 2)).*(Vd*c)
      Vmath::Vmul(uhatstot, &Vxy[0]+i, totpts, &Vxy[0]+i, totpts, &temp2[0], 1);

 
        
      v2  = Vmath::Vsum(uhatstot, temp2, 1);  
 
      Vmath::Vmul(uhats.size(), &Vxyd0[i], totpts, &uhats[0], 1, &temp2[0], 1);

      v1= v2*Vmath::Vsum(uhats.size(), temp2, 1)- v1;
  
      pqeval[i] = v1;
 

      if(dimension > 1)
        {
	  Vmath::Vmul(modes, &Vxy[0]+i, totpts, &Vxyd1[0]+i, totpts, &temp2[0], 1);
	  v1  = Vmath::Vsum(modes, temp2, 1); 
	  Vmath::Vmul(uhatstot, &Vxy[i], totpts, &uhats[0], 1, &temp3[0], 1);

	  v2  = Vmath::Vsum(uhatstot, temp3, 1);  

	  v1 = v2*v1;

	  // At this point,                 

	  // v1 = (sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) for 1 point

	  // calculate (sum(Vxm1.*Vxm1, 2)).*(Vd*c)
	  Vmath::Vmul(uhatstot, &Vxy[0]+i, totpts, &Vxy[0]+i, totpts, &temp2[0], 1);

 
        
	  v2  = Vmath::Vsum(uhatstot, temp2, 1);  
 
	  Vmath::Vmul(uhats.size(), &Vxyd1[i], totpts, &uhats[0], 1, &temp2[0], 1);

	  v1=  v2*Vmath::Vsum(uhats.size(), temp2, 1) - v1;
 
	  pqeval[i] += v1;
 
        }
      if(dimension == 3)
        {
	  Vmath::Vmul(modes, &Vxy[0]+i, totpts, &Vxyd2[0]+i, totpts, &temp2[0], 1);
	  v1  = Vmath::Vsum(modes, temp2, 1); 
	  Vmath::Vmul(uhatstot, &Vxy[i], totpts, &uhats[0], 1, &temp3[0], 1);

	  v2  = Vmath::Vsum(uhatstot, temp3, 1);  

	  v1 = v2*v1;

	  // At this point,                 

	  // v1 = (sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) for 1 point

	  // calculate (sum(Vxm1.*Vxm1, 2)).*(Vd*c)
	  Vmath::Vmul(uhatstot, &Vxy[0]+i, totpts, &Vxy[0]+i, totpts, &temp2[0], 1);

 
        
	  v2  = Vmath::Vsum(uhatstot, temp2, 1);  
 
	  Vmath::Vmul(uhats.size(), &Vxyd2[i], totpts, &uhats[0], 1, &temp2[0], 1);

	  v1= v2*Vmath::Vsum(uhats.size(), temp2, 1) - v1;
 
	  pqeval[i] += v1;
 
        }
    }
  // Vmath::Vmul(pqeval.size(), pqeval, 1, E->GetBasis(0)->GetW(), 1, pqeval, 1);        

  // for(int i = 0; i<ret.size(); i++)
  // {
        
  //     Vmath::Vmul(totpts, &V3[i], ret.size(), &pqeval[0], 1, &temp[0], 1);
        
  //     ret[i] = Vmath::Vsum(totpts, temp, 1);  
        
  // }
  E3seg->FwdTrans(pqeval, ret);
    
}


// sig = 0 -> called by opt_needed
// sig = 1 -> called by sphere_rotation
Array<OneD, Array< OneD,  NekDouble> > call_find_roots(Array<OneD,  NekDouble> &uhats , int d, Array<OneD, Array<OneD, NekDouble> >&uhatsedges, Array<OneD, Array<OneD, NekDouble> >&surfaceuhats, int sig)
{

  boost::ignore_unused(d);
  int dimension = E->GetShapeDimension(); 
  vector<vector< NekDouble> > ret(dimension);

  cout<<"\n";
  Array<OneD, Array<OneD, NekDouble> > retarr;//(dimension);

  if(dimension == 3) //3D
    {
      if(numedges == 9) //prism
        {

	  for(int ii = 0; ii < numedges; ii++)
            {
    
	      vector<vector<NekDouble> > tmp(dimension);
	      if(sig == 0)
		{
		  tmp  = (find_roots(uhatsedges[ii], NullNekDouble1DArray, 1, 0, sig)) ;
		}
	      else
		{
		  tmp  = (find_roots(uhatsedges[ii], NullNekDouble1DArray, 0, 0, sig)) ;
		}
	      for(int p = 0; p < tmp[0].size(); p++)
                {
		  if(ii == 0) // edge front left (x = -1) (y = -1)
                    {
		      ret[1].push_back(-1);
		      ret[2].push_back(tmp[0][p]);
		      ret[0].push_back(-1);
                        
                    }
		  else if(ii == 1) //edge front hypt (y = -1) (z = -x)
                    {
		      ret[0].push_back(tmp[0][p]);
		      ret[2].push_back(-tmp[0][p]);
		      ret[1].push_back(-1);
			
		      ret[0].push_back(-tmp[0][p]);
		      ret[2].push_back(tmp[0][p]);
		      ret[1].push_back(-1);
                    }
		  else if(ii == 2) //edge front bot (y = -1) (z = -1)

                    {
		      ret[0].push_back(tmp[0][p]);
		      ret[1].push_back(-1);
		      ret[2].push_back(-1);
                    
                    
                    }
		  else if(ii == 3) //edge back left (y = 1), (x = -1)
                    {
		      ret[0].push_back(-1);
		      ret[1].push_back(1);
		      ret[2].push_back(tmp[0][p]);
                    }
		  else if(ii == 4) //edge backhypt ( y = 1) (z = -x)
                    {
		      ret[1].push_back(1);
		      ret[0].push_back(tmp[0][p]);
		      ret[2].push_back(-tmp[0][p]);

		      ret[1].push_back(1);
		      ret[0].push_back(-tmp[0][p]);
		      ret[2].push_back(tmp[0][p]);
		    }
                    
		  else if(ii == 5) //edge back bot (y = 1) (z = -1)
                    {
		      ret[1].push_back(1);
		      ret[0].push_back(tmp[0][p]);
		      ret[2].push_back(-1);
                    }
		  else if(ii == 6)//edge left bot (z = -1), (x = -1)  
                    {
		      ret[0].push_back(-1);
		      ret[1].push_back(tmp[0][p]);
		      ret[2].push_back(-1);
                    }
		  else if(ii == 7) // edge left top (x = -1), (z = 1))
                    {
		      ret[2].push_back(1);
		      ret[1].push_back(tmp[0][p]);
		      ret[0].push_back(-1);
                    }
		  else if(ii == 8) //edge right bot ( z = -1) (x = 1)
                    {
		      ret[2].push_back(-1);
		      ret[1].push_back(tmp[0][p]);
		      ret[0].push_back(1);
                    }
                    
                }
            

            
            }
        }
      if(numsurfaces == 5)
        {   
	  // call 2D rootfinder on each surface:
	  vector<vector<NekDouble> > tmp(dimension);
            
	  for(int ii = 0; ii < numsurfaces; ii++)
            {
                  
                
	      if(ii == 0) //surf bot z = -1
                {
		  tmp  = (find_roots(surfaceuhats[ii], Vxyzm1, 0, 1, sig, 1, ii)) ;  
		  for(int p = 0; p < tmp[0].size(); p++)
                    {

		      ret[2].push_back(-1);
		      ret[1].push_back(tmp[1][p]);
		      ret[0].push_back(tmp[0][p]);
                    }
                }
                    
	      else if(ii == 1) //surf left x = -1
                {
		  tmp  = (find_roots(surfaceuhats[ii], Vxzmy, 0, 1, sig, 1, ii)) ;  
		  for(int p = 0; p < tmp[0].size(); p++)
                    {
                    
		      ret[0].push_back(-1);
		      ret[2].push_back(tmp[1][p]);
		      ret[1].push_back(tmp[0][p]);
                    }
                }
	      else if(ii == 2) //surface hypt x+z = 0

                {
		  tmp  = (find_roots(surfaceuhats[ii], Vxm1yz, 0, 1, sig, 1, ii)) ;

		  for(int p = 0; p < tmp[0].size(); p++)
                    {  

		      ret[2].push_back(-tmp[0][p]);
		      ret[1].push_back(tmp[1][p]);
		      ret[0].push_back(tmp[0][p]);
		      ret[2].push_back(tmp[0][p]);
		      ret[1].push_back(tmp[1][p]);
		      ret[0].push_back(-tmp[0][p]);
                    }
                }
	      else if(ii == 3) //surf front y = -1
                {
                    
		  tmp  = (find_roots(surfaceuhats[ii], Vxym1z, 0, 1, sig, 1, ii)) ;  
		  for(int p = 0; p < tmp[0].size(); p++)
                    {
		      ret[1].push_back(-1);
		      ret[2].push_back(tmp[1][p]);
		      ret[0].push_back(tmp[0][p]);
                    }
                }
	      else if(ii == 4) //surf back y = 1
                {
                
		  // tri so last arg is 1
		  tmp  = (find_roots(surfaceuhats[ii], Vxy1z, 0, 1, sig, 1,  ii)) ;  
		  for(int p = 0; p < tmp[0].size(); p++)
                    {
		      ret[1].push_back(1);
		      ret[2].push_back(tmp[1][p]);
		      ret[0].push_back(tmp[0][p]);
                    }
                    
                }
            }
        }
            
      //find interior roots:
      vector<vector<NekDouble> > tmp;

      tmp =  (find_roots(uhats, interioreval3d, 0, 1, sig)) ;

      if(tmp[0].size() > 0)
        {
	  for(int p = 0; p <dimension; p++)
            {
	      ret[p].push_back(tmp[p][0]);
            }
        }

    }
  retarr = vectoarr(ret);

  return retarr;
}


// Called by call_find_roots depending on edges or interior region 
// rootfinding
// d=1 :: derivatives
// flag = 0, edges (1D rootfinding using confederate matrix)
// flag = 1, interior region rootfinding using gradient descent
// sig = 0 -> called by opt_needed
// sig = 1 -> called by sphere_rotation
// surfflag = 0 -> only minima in 3D volume in gradient descent
// surffflag = 1 -> minima in the area of 2D surfaces using grad descent
vector<vector<NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> evalxyz, int d, int flag ,int sig, int surfflag, int surfid)
{

  vector<vector< NekDouble> > ret(dimension);
  //Confederate matrix approach
  if(dimension == 1 || flag == 0)
    {
      int N = uhats.size();

      vector<NekDouble> uhatsmon;
      while(abs(uhats[N-1])<1e-9)
        {
	  N = N-1;
            
	  if(N == 0)
            {
        
	      ret[0].push_back(-1.0);
	      ret[1].push_back(1.0);
                
	      return ret;
            }

        }

      vector<NekDouble> temp(N);
      // convert uhats to monomial, find roots of uhats or der of uhats
      for(int k = 0; k < N; k++)
        {
	  for(int jj= 0 ; jj < N; jj++)
            {
	      temp[jj ] = C[jj][k];
            }
	  Vmath::Vmul(N, &temp[0], 1,  &uhats[0], 1, &temp[0], 1);
	  NekDouble temp2 = Vmath::Vsum(N, &temp[0], 1);
	  uhatsmon.push_back(temp2);
        }

      if(abs(Vmath::Vmax(uhatsmon.size(), &uhatsmon[0], 1))<1e-10)
      {
          ret[0].push_back(-1.0);
          ret[1].push_back(1.0);
            
          return ret;
         
      }

      // truncate trailing zeros
      while(abs(uhatsmon[N-1])<1e-8)
        {
	  N = N-1;
	  if(N == 0)
            {
        
	      ret[0].push_back(-1.0);
	      ret[1].push_back(1.0);
                
	      return ret;
            }

        }
      //N = uhatsmon.size();

      if(N == 0 || Vmath::Vmin(N,&uhatsmon[0],1)<-1e10)
          {
              ret[0].push_back(-1.0);
              ret[1].push_back(1.0);
                
              return ret;
          }

      	
      // now size of uhatsmon = N;
      vector<NekDouble> uhatsdiff;
      // if d == 1,

      if(d == 1)
        {
	  for(int k = 1; k < N; k++)
            {
	      uhatsdiff.push_back(k*uhatsmon[k]);
            }
	  N = N-1;
	  if(N == 0)
            {
	      ret[0].push_back(-1.0);
	      ret[1].push_back(1.0);
                
	      return ret;
            }
        
        }
      else //d == 0
        {
	  //            uhatsdiff = uhatsmon;
	  for(int k = 0; k<N; k++)
	    uhatsdiff.push_back(uhatsmon[k]);
        }
        
      if(N == 1)
      {
          ret[0].push_back(-1.0);
          ret[1].push_back(1.0);
                
          return ret;
      }
        
      Vmath::Smul(N, 1.0/uhatsdiff[N-1], &uhatsdiff[0], 1, &uhatsdiff[0], 1);


      vector<NekDouble> EIG_R = demo.FindEigenval(uhatsdiff, N);


      for(int kk = 0; kk <EIG_R.size(); kk++)
        {   
	  ret[0].push_back( EIG_R[kk] );
            
        }


    }
  else if(dimension > 1 && flag == 1)
    {    
      // surfid can be between 1 and 5
      ret = gradient_descent(uhats, evalxyz, sig, surfflag, surfid);
       
    }


  return ret;    
    
}

// sig = 1 -> from do_opt
// sig = 0 -> from opt_needed
// surfflag = 0 -> volume
// surfflag = 1 -> surfaces
vector< vector< NekDouble> >  gradient_descent(Array<OneD, NekDouble> uhats, Array<OneD, NekDouble> evalxyz, int sig, int surfflag, int surfid  )
{        
  boost::ignore_unused(surfid);
  // Gradient descent
  int temp_dim = dimension;
  // if(surfflag == 1)
  //     temp_dim = dimension - 1;
  // Assert that d = 0
        
  Array<OneD, NekDouble> g(temp_dim);
  double inf = numeric_limits<double>::infinity();

  Array<OneD,NekDouble> xnew(temp_dim) ,x(temp_dim);
  NekDouble gprev = inf; // use inf
  int idxgprev;
  Array<OneD, NekDouble> tmp(temp_dim);
  Array<OneD, Array<OneD, NekDouble> > xarr(temp_dim);
  vector< vector< NekDouble> > ret(temp_dim);
  Array<OneD, Array<OneD, NekDouble> > tc(temp_dim);
  StdExpansion *tempE;
  Array<OneD, NekDouble> eval;
  int sz;
  tempE = E;
  Array<OneD, Array<OneD, NekDouble > > tempeval(4);
  if( (dimension == 3 && surfflag == 1))
    {

      //assert surfid is in 0-4
      tc = surfcoords[surfid];//testcoord2dquad;
      sz = tc[0].size();
      eval = evalxyz;
    }
  else //dim = 3 and surfflag is off
    {
      tc =  testcoord3d;
      sz = tc[0].size();

      eval = interioreval3d;// testcoord2d;
      // eval[1] = interioreval3d0;// testcoord2d;
      // eval[2] = interioreval3d1;// testcoord2d;
      // eval[3] = interioreval3d2;// testcoord2d;
    
    }
  for(int i = 0; i < 4; i++)
    {
      tempeval[i] = Array<OneD, NekDouble>(E->GetNcoeffs());  
    }
    
  Array<OneD, NekDouble> nullarr(0);
  Array<OneD, NekDouble> temp2(sz);

  if(sig==0)
    {

      Array<OneD, NekDouble> temp(uhats.size());
 
      for(int k = 0; k < sz; k++)
        {

	  Vmath::Vmul(uhats.size(), &eval[k], sz, &uhats[0], 1, &temp[0], 1);          
	  temp2[k] = Vmath::Vsum(temp.size(), temp, 1);
        }
      gprev = Vmath::Vmin(temp2.size(), temp2, 1);	
      idxgprev = Vmath::Imin(sz, temp2, 1);        
            
    }
  else
    {
      pq(uhats, tc, eval, nullarr, temp2 );
      gprev = Vmath::Vmin(sz, temp2, 1);
      idxgprev = Vmath::Imin(sz, temp2, 1);
    }
      xnew[0] = tc[0][idxgprev];
      xnew[1] = tc[1][idxgprev];
      xnew[2] = tc[2][idxgprev]; 
    
  //     //  }
  //     // else
  //     // {
  //     //     gprev = 1; // don't call grad_desc iterations
  //     // }
  //   }
  // else
  //   {

  //     // switch(surfid)
  //     // {
  //     // case 0: // bot // z = -1
  //     //     xnew[0] = tc[0][idxgprev];
  //     //     xnew[1] = tc[1][idxgprev];
  //     //     xnew[2] = -1.0;
  //     //     break;
  //     // case 1: //surface hypt x+z = 0
  //     //     xnew[0] = tc[0][idxgprev];
  //     //     xnew[1] = tc[1][idxgprev];
  //     //     xnew[2] = -1.0;//-xnew[0];
  //     //     break;
  //     // case 2: //surface left x = -1
  //     //     xnew[2] = tc[1][idxgprev];
  //     //     xnew[1] = tc[0][idxgprev];
  //     //     xnew[0] = -1.0;
  //     //     break;
  //     // case 3: //surface front y = -1
  //     //     xnew[0] = tc[0][idxgprev];
  //     //     xnew[1] = tc[1][idxgprev];//-1.0;
  //     //     xnew[2] = tc[2][idxgprev];
  //     //     break;
  //     // case 4: //surface back y = 1
  //     //     xnew[1] = 1.0;
  //     //     xnew[0] = tc[0][idxgprev];
  //     //     xnew[2] = tc[1][idxgprev];
  //     //     break;
  //     // default: cout<<"\n invalid edge id!!\n\n";
  //     //     exit(0);
  //     //     break;
  //     // }

  //     xnew[0] = tc[0][idxgprev];
  //     xnew[1] = tc[1][idxgprev];
  //     xnew[2] = tc[2][idxgprev];


  //     // if(xnew[0] + xnew[2] > 0) 
  //     // {
  //     //     gprev = 1; // skip calling next iters
  //     // }
  //   }

  if(gprev < 0 && abs(gprev)>1e-11)
    {
      int n = 0;
      NekDouble epsl = 1.0;
       
      // cout<<"\n GD: starting... gprev ="<<gprev<<" x = "<<xnew[0]<<" y = "<<xnew[1]<<" ";
      // if(temp_dim ==3)
      // {
      //     cout<<" z = "<<xnew[2];
      // }

      iterGD = 1e-2;
      secarg = 1e3;
      NekDouble stepsize = iterGD, iter = secarg;
      Array<OneD, Array<OneD, NekDouble> > xastaa(dimension);

      Array<OneD, NekDouble> dereval(temp_dim);
      Array<OneD, NekDouble> xsave(xnew.size());
      for(int k = 0; k < temp_dim; k++)
	xsave[k] = xnew[k];
      // loop for gradient descent 2D:
        
      bool res, res2 = true;
        
      Array<OneD, NekDouble> temp1 (uhats.size());
      while(n < iter)
        {
	  epsl = 0.0;

	  for(int p = 0; p < dimension; p++)
            {

	      xastaa[p] = Array<OneD, NekDouble>(1,xnew[p]);
            }   

	  tempE->PhysEvalBasisGrad(xastaa, tempeval[0], tempeval[1], tempeval[2], tempeval[3]);
	  // multiply tempeval by uhats to get g[p]

	  if(sig == 0) // from opt_needed
            {
                
	      for(int p = 0; p < dimension; p++)
                {
		  Vmath::Vmul(uhats.size(), &tempeval[p+1][0], 1, &uhats[0], 1, &temp1[0], 1 );
		  g[p] = Vmath::Vsum(temp1.size(), temp1, 1);

		  epsl += abs(g[p]);
                }
            }
	  else
            {
	      for(int p = 0; p < dimension; p++)
                {
		  derpq(uhats, dereval[p], tempeval[0], tempeval[p+1]);
		  g[p] = dereval[p];
		  epsl += abs(g[p]);
                }
            }
	  if(surfflag == 1)
	    {
	      switch(surfid)
		{
		case 0: // bot // z = -1
		  x[0] = xnew[0] - stepsize*(g[0]);//tc[0][idxgprev];
		  x[1] = xnew[1] - stepsize*(g[1]);//tc[1][idxgprev];
		  x[2] = -1.0;
		  break;
		case 1: //surface hypt x+z = 0
		  x[0] = xnew[0] - stepsize*(g[0]);//tc[0][idxgprev];
		  x[1] = xnew[1] - stepsize*(g[1]);//tc[1][idxgprev];
		  x[2] = -1.0*(xnew[0] - stepsize*(g[0]));//-xnew[0];
		  break;
		case 2: //surface left x = -1
		  x[2] = xnew[2] - stepsize*(g[2]);//tc[1][idxgprev];
		  x[1] = xnew[1] - stepsize*(g[1]);;
		  x[0] = -1.0;
		  break;
		case 3: //surface front y = -1
		  x[0] = xnew[0] - stepsize*(g[0]);//tc[0][idxgprev];
		  x[1] = -1.0;
		  x[2] = xnew[2] - stepsize*(g[2]);
		  break;
		case 4: //surface back y = 1
		  x[1] = 1.0;
		  x[0] = xnew[0] - stepsize*(g[0]);
		  x[2] = xnew[2] - stepsize*(g[2]);//tc[1][idxgprev];
		  break;
		default: cout<<"\n invalid surf id!!\n\n";
		  exit(0);
		  break;
		}
	    }
	  else
	    {
	      x[0] = xnew[0] - stepsize*(g[0]);
	      x[1] = xnew[1] - stepsize*(g[1]);
	      x[2] = xnew[2] - stepsize*(g[2]);
	    }
            
            
	  //res2 = (abs(x[0]) <= 1) && (abs(x[1])<=1) && (abs(x[2])<=1) ;
	  // for(int k = 0; k < temp_dim; k++)
	  // {   
	  //     if(abs(x[k])-abs(xnew[k]) > 1e-10)
	  //     {
	  //         res2 = res2 && false;
	  //         break;
	  //     }
	  // }

	  if( (std::isnan(epsl)) || (epsl <1e-10) || (epsl>1e3))
	    {
	      //                cout<<"\n break! n = "<<n<<"surfflag  ="<<surfflag<<"\n"<<" epsl = "<<epsl;//<<" x[0]="<<x[0]<<" x[1]="<<x[1]<<" xnew[0] = "<<xnew[0]<<"xnew[1] = "<<xnew[1]<<" x[0]-xnew[0] = "<<x[0]-xnew[0]<<" x[1]-xnew[1] = "<<x[1]-xnew[1];                ;                
	      break;
	    }
	  for(int p = 0; p < dimension; p++)
	    {
                xnew[p] = x[p];
            }            
            
            n = n+1;
            
            
        }
      
	if(surfflag == 0)
	  res = (x[0]+x[2])<=0;
        for(int k = 0; k < temp_dim; k++)
        {
            if(abs(x[k]) >1.0)
            {
                res2 = false;
                break;
            }
        }   
        //check
        if((res2 && res && n < iter &&(!std::isnan(epsl))))
        {
            for(int p = 0; p < temp_dim; p++)
            {
                ret[p].push_back( (x[p]));
            }
        }
    
        else
        {
            for(int p = 0; p < temp_dim; p++)
            {
                
                ret[p].push_back(xsave[p]);
            }
            
        }
    
    }

    return ret;
}
    
    
    
void derpq(Array<OneD, NekDouble> &uhats, NekDouble &ret,  Array<OneD, NekDouble> Vxy, Array<OneD, NekDouble> Vxyd)
{
    int N = uhats.size();
    Array<OneD, NekDouble> temp(N);
    //\sum(phi^2)
    Vmath::Vmul(N, Vxy, 1, Vxy, 1, temp, 1); 
    NekDouble tmp = Vmath::Vsum(N, temp, 1);

  
    //\sum(u*phi')
    Vmath::Vmul(N, uhats, 1,Vxyd, 1, temp, 1);
    NekDouble v1 = Vmath::Vsum(N, temp, 1);
  
    v1 = v1*( Vmath::Vsum(N, temp, 1))*pow(tmp, -0.5);
    //  NekDouble v2 = pow(tmp , -1.5);

    //\sum(phi*phi')
    Vmath::Vmul(N, Vxy, 1,Vxyd, 1, temp, 1);
    NekDouble v2  = Vmath::Vsum(N, temp, 1);

    //\sum(u*phi)
    Vmath::Vmul(N, uhats, 1, Vxy, 1, temp, 1); 
    v2 = v2*Vmath::Vsum(N, temp, 1);

    //\sum(phi*phi)^(-3/2)
    //  Vmath::Vmul(N, Vxy, 1,Vxyd1, 1, temp, 1);
        v2 = v2*( pow(tmp,-1.5));

    ret = v1-v2;
} 

int Opt_needed(Array<OneD, NekDouble> uhats, int flag )
{
    int totModes = uhats.size();
    Array<OneD,  Array<OneD, NekDouble> > rootsarr;
    Array<OneD, Array<OneD, NekDouble> > edgeuhats  (numedges);
    Array<OneD, Array<OneD, NekDouble> > surfacederuhats  (numsurfaces);
    //find edge roots: (edges = 5 is prism)
    //project_surfaces(uhats, surfacederuhats, 0);
    //    cout<<"\n surfuhats:\n";
    for(int t = 0; t <numsurfaces; t++)
    {
        surfacederuhats[t] = Array<OneD, NekDouble>(uhats);
        
    }

    project_edges(uhats, edgeuhats);

    //find roots of der of uhats, that is why d = 0
    rootsarr = call_find_roots(uhats, 0, edgeuhats, surfacederuhats, 0);

    // evaluate ortho basis at roots
    // evalBasisRoots is flattened basis eval matri
        
      

    int     evalsz = (rootsarr[0].size())*totModes;
    Array<OneD, NekDouble> evalBasisRoots(evalsz);//, vals(roots[0].size()); 

    E->PhysEvalBasisGrad(rootsarr, evalBasisRoots, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
  
    Array<OneD, NekDouble> tmp(rootsarr.size()),temp(totModes) ;

    NekDouble minv = numeric_limits<double>::infinity();
    int idx = 0;
    for(int k = 0; k < rootsarr[0].size(); ++k)
    {
        NekDouble tempv;
        Vmath::Vmul(totModes, &evalBasisRoots[k], rootsarr[0].size(), &uhats[0], 1, &temp[0], 1);
        tempv = Vmath::Vsum(temp.size(), temp, 1);
        if(tempv < minv )
        {
            minv = tempv;
            idx = k;
        }
        
    }
         
    cout<<"\n minv = "<<minv<<" at ";
    for(int k = 0; k < rootsarr.size(); k++)
    {
        cout<<rootsarr[k][idx]<<" ";
    }
    if(minv < 0.0 && abs(minv)>1e-10)
    {
        if(flag == 0)
        {
            startval = minv;
            startcoordx = rootsarr[0][idx];
            startcoordy = rootsarr[1][idx];
            startcoordz = rootsarr[2][idx];
     
        }
        return 1;
    }
    return 0;
}
void pq(
        Array<OneD,NekDouble> uhats,
        Array<OneD, Array<OneD,  NekDouble> > roots,
        Array<OneD, NekDouble> V1,
        Array<OneD,NekDouble> &pqevalxast,
        Array<OneD,NekDouble> &fvals
        )
{
    //    boost::ignore_unused(tempE);
    int N = uhats.size();
    Array<OneD,NekDouble> w1(N);
    // Array<OneD, NekDouble> V1(roots[0].size()*N);
  
    vector<NekDouble> Vsumsq;
    
    // tempE->PhysEvalBasisGrad(roots, V1, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
    
    // V1 is flattened basis eval matrix
    
    // V2 = mat_mat_dot(V1,V1);
    // and
    // vector<double> Vsum = mat_sum_dim(V2,2);
    
    for(int i = 0; i < roots[0].size(); i++)
    {

        Vmath::Vmul(N, &V1[i], roots[0].size(), &uhats[0], 1, &w1[0], 1);
        fvals[i] = ( Vmath::Vsum(N, &w1[0], 1));
    
    }
    for( int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i], roots[0].size(), &V1[i], roots[0].size(), &w1[0], 1);

        Vsumsq.push_back(pow(Vmath::Vsum(N, &w1[0], 1),-0.5));
    }


    //    cts = vec_vec_dot(Vsumsq, ret);
    Vmath::Vmul(roots[0].size(), &Vsumsq[0], 1, &fvals[0], 1, &fvals[0], 1);
    // cout<<"\nfvals:  ";
    // for(int p = 0; p < fvals.size(); p++)
    //   cout<<fvals[p]<<" ";
    
    if(pqevalxast.size() > 0)
    {
                   
        int minidx = Vmath::Imin(fvals.size(), &fvals[0], 1);
        pqevalxast[0] = fvals[minidx];
        for(int k = 0; k < pqevalxast.size()-1; k++)
        {
            pqevalxast[k+1] = roots[k][minidx];
        }
    }

                   
}



void Do_optimize(Array<OneD, NekDouble> &uhats)
{

    int dim = E->GetShapeDimension();
    double inf = numeric_limits<double>::infinity();
    
    //assert(size(constraints, 1) == N+2);
    
    int N1 = uhats.size();
    vector<Array<OneD,NekDouble> > d;
 
    d.push_back(uhats);
    int counter = 0;
      
    //    int NC = ck[1].size();          // number of constraints
    vector<double> tols;         // constraint specific tolerances

    int niter = 1e3;
    Array<OneD, Array<OneD,NekDouble> > optima;
     
    //    int NC = 1; //number of constraints, only positivity for now
    tols.push_back(1e-10);
    
    Array<OneD, NekDouble>  pqvalcoords(dim+1), xastarr(dim), utemp(N1), xastarrhist(dim), wsp1;   
    

    Array<OneD, Array<OneD, NekDouble> > surfaceuhats  (numsurfaces);
    Array<OneD, Array<OneD, NekDouble> > Pf(numedges);
    for(int k= 0; k < numedges; k++)
    {
            
        Pf[k] = Array<OneD, NekDouble>(E3seg->GetNcoeffs());//(3*(E->GetBasis(0)->GetNumModes()-1));        
    }
    
    NekDouble pqval;
    while (counter <= niter)
    {
        pqval = inf;
        utemp = d.back();

        //pq = @(xx) cfun(xx) .* (constraints(1,jj).*Vc(xx)*uhats);  
        project_edges(utemp, Pf, 1);
        
        // if(dimension > 2)
        // {
        //     //find surface roots: (surfaces = 12 is hex)
        
        //     project_surfaces(utemp, surfaceuhats, 1);

        
        // }
        for(int k = 0; k < numsurfaces; k++)
        {
            surfaceuhats[k] = Array<OneD, NekDouble>(uhats);
        }
        optima = (call_find_roots(utemp, 0, Pf, surfaceuhats, 1));
	// cout<<" roots:  \n";
	// for(int k = 0; k < optima.size(); k++)
	//   {
	//     for(int p = 0; p <optima[0].size(); p++)
	//       {
	// 	cout<<optima[k][p]<<" ";
	//       }
	//     cout<<"\n";
	    
	//   }
	// cout<<"\n";
        wsp1 = Array<OneD, NekDouble>(optima[0].size());
        
        // Vtmp is evaluation of basis fn at optima
        Array<OneD, NekDouble> Vtmp(optima[0].size() * E->GetNcoeffs());
        E->PhysEvalBasisGrad(optima, Vtmp, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
        pq(utemp, optima, Vtmp,  pqvalcoords, wsp1);


        if (pqvalcoords[0] < pqval)
        {
            for(int k = 0; k  < dimension; k++)
            {
                xastarr[k] = pqvalcoords[k+1];
            }
            pqval = pqvalcoords[0];
        }
        
        cout<<"\n at counter="<<counter<<" min val="<<pqval<<" xast ="<<xastarr[0]<<" "<<xastarr[1]<<" "<<xastarr[2];//<< "diff ="<<xastarrhist[0] - xastarr[0]<<" "<<xastarrhist[1] - xastarr[1] <<" "<<xastarrhist[2] - xastarr[2];
        xastarrhist[0] = xastarr[0];   
        xastarrhist[1] = xastarr[1];        
        xastarrhist[2] = xastarr[2];
        // If minimum is non-negative, we're done
        if (pqval >= -tols.at(0))
        {
            break;
        }
        
        //vector<NekDouble> Vastsq;
        //        vector<NekDouble> Vast;
        Array<OneD, NekDouble> Vast(uhats.size()), Vastsq(uhats.size());
        Array<OneD, Array<OneD, NekDouble> > xastarr2(3);
        xastarr2[0] = Array<OneD, NekDouble>(1, xastarr[0]);
        xastarr2[1] = Array<OneD, NekDouble>(1, xastarr[1]);
        xastarr2[2] = Array<OneD, NekDouble>(1, xastarr[2]);
        NekDouble vastsqsum;

        // for( int ii = 0; ii < N1; ii++)
        // {
        //     Vast.push_back(E->PhysEvaluateBasis(xastarr, ii));
        //     Vastsq.push_back(Vast[ii]*Vast[ii]);
        
        // }
        E->PhysEvalBasisGrad(xastarr2, Vast, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
        Vmath::Vmul(uhats.size(), Vast, 1, Vast, 1, Vastsq, 1);
        vastsqsum = Vmath::Vsum(N1, &Vastsq[0], 1);

        Array<OneD, NekDouble>  qast(N1);
        //cout<<"\n correction:";
        for(int i = 0; i<N1; i++)
        {
            qast[i] = ((1/sqrt(vastsqsum))*(Vast[i]));
            //  cout<<qast[i]<< " ";
        }
        Vmath::Smul(N1, pqval, &qast[0], 1, &qast[0], 1);
        
        Vmath::Vsub(utemp.size(), &utemp[0], 1, &qast[0], 1, &qast[0], 1);
        // cout<<"\n        uhats chng:";
        // for(int i = 0; i<utemp.size(); i++)
        // {
        //     cout<<utemp[i] - qast[i]<<" ";
        // }

        d.push_back(qast);

        counter = counter + 1;
    
    
    }
    cout<<"sphere_rotation took "<<counter<<"startv = "<<startval<<" at startcoords("<<startcoordx<<","<<startcoordy<<" ," <<startcoordz<<")   iterations\n  GD iter stepszie ="<<iterGD<<" maxiters = "<<secarg<<" o = "<<E->GetBasis(0)->GetNumModes()<<" p = "<<E->GetBasis(0)->GetNumPoints()<<" prism \n";;
    uhats = d.back();
}


NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff)
{
    map<ShapeType, function<int(int, const vector<int> &)>> shapeConstraint2;
    shapeConstraint2[ePoint] =
[](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eSegment] =
[](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eTriangle] =
[](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[eQuadrilateral] =
[](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eTetrahedron] =
[](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePyramid] =
[](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePrism] =
[](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eHexahedron] =
[](int,   const vector<int> &order) { return order[1]; };

    map<ShapeType, function<int(int, int, const vector<int> &order)>>
        shapeConstraint3;
    shapeConstraint3[ePoint] =
[](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eSegment] =
[](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTriangle] =
[](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eQuadrilateral] =
[](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTetrahedron] =
[](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePyramid] =
[](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePrism] =
[](int k, int,   const vector<int> &order) { return order[2] - k; };
    shapeConstraint3[eHexahedron] =
[](int,   int,   const vector<int> &order) { return order[2]; };

    NekDouble sol = 0.0;
    if (!diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += sin(k * M_PI * x) + cos(k * M_PI * x);
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eSegment)
        {
            sol += 0.25 * sin(M_PI * x) + 0.25 * cos(M_PI * x);
        }
        else if (btype[0] == eFourier && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1] / 2; ++l)
                    {
                        sol += sin(k * M_PI * x) * sin(l * M_PI * y) +
                            sin(k * M_PI * x) * cos(l * M_PI * y) +
                            cos(k * M_PI * x) * sin(l * M_PI * y) +
                            cos(k * M_PI * x) * cos(l * M_PI * y);
                    }
                }
            }
            else if (btype[1] == eFourierSingleMode)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    sol += sin(k * M_PI * x) * sin(M_PI * y) +
                        sin(k * M_PI * x) * cos(M_PI * y) +
                        cos(k * M_PI * x) * sin(M_PI * y) +
                        cos(k * M_PI * x) * cos(M_PI * y);
                }
            }
            else
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1]; ++l)
                    {
                        sol += sin(k * M_PI * x) * pow_loc(y, l) +
                            cos(k * M_PI * x) * pow_loc(y, l) ;
                    }
                }
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(M_PI * x) * sin(l * M_PI * y) +
                        sin(M_PI * x) * cos(l * M_PI * y) +
                        cos(M_PI * x) * sin(l * M_PI * y) +
                        cos(M_PI * x) * cos(l * M_PI * y);
                }

            }
            else if (btype[1] == eFourierSingleMode)
            {
                sol += sin(M_PI * x) * sin(M_PI * y) +
                    sin(M_PI * x) * cos(M_PI * y) +
                    cos(M_PI * x) * sin(M_PI * y) +
                    cos(M_PI * x) * cos(M_PI * y);
            }
            else
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += sin(M_PI * x) * pow_loc(y, l) +
                        cos(M_PI * x) * pow_loc(y, l);
                }
            }
        }
        else if (btype[1] == eFourier && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(l * M_PI * y) * pow_loc(x, k) +
                        cos(l * M_PI * y) * pow_loc(x, k);
                }
            }
        }
        else if (btype[1] == eFourierSingleMode && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                sol += sin(M_PI * y) * pow_loc(x, k) +
                    cos(M_PI * y) * pow_loc(x, k);
            }
        }
        else
        {
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        sol += pow_loc(x, k) * pow_loc(y, l) * pow_loc(z, m);
                    }
                }
            }
        }
    }
    else if (diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += k * M_PI * (cos(k * M_PI * z) - sin(k * M_PI * z));
            }
        }
        else if (btype[0] != eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += k * pow_loc(x, k - 1) * sin(M_PI * l * y)
                        + M_PI * l * pow_loc(x, k) * cos(M_PI * l * y) +
                        +k * pow_loc(x, k - 1) * cos(M_PI * l * y)
                        - M_PI * l * pow_loc(x, k) * sin(M_PI * l * y);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] != eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * pow_loc(y, l)
                        + l * sin(M_PI * k * x) * pow_loc(y, l - 1) +
                        -M_PI * k * sin(M_PI * k * x) * pow_loc(y, l)
                        + l * sin(M_PI * k * x) * pow_loc(y, l - 1);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * sin(M_PI * l * y)
                        + M_PI * l * sin(M_PI * k * x) * cos(M_PI * l * y)
                        + M_PI * k * cos(M_PI * k * x) * cos(M_PI * l * y)
                        - M_PI * l * sin(M_PI * k * x) * sin(M_PI * l * y)
                        - M_PI * k * sin(M_PI * k * x) * sin(M_PI * l * y)
                        + M_PI * l * cos(M_PI * k * x) * cos(M_PI * l * y)
                        - M_PI * k * sin(M_PI * k * x) * cos(M_PI * l * y)
                        - M_PI * l * cos(M_PI * k * x) * sin(M_PI * l * y);
                }
            }
        }
        else
        {
            NekDouble a;
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        a = k * pow_loc(x, k - 1) * pow_loc(y, l) *
                            pow_loc(z, m);
                        sol += a;
                        a = l * pow_loc(x, k) * pow_loc(y, l - 1) *
                            pow_loc(z, m);
                        sol += a;
                        a = m * pow_loc(x, k) * pow_loc(y, l) *
                            pow_loc(z, m - 1);
                        sol += a;
                    }
                }
            }
        }
    }

    return sol;
}
