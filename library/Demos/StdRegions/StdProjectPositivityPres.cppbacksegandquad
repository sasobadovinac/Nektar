///////////////////////////////////////////////////////////////////////////////
//
// File: NodalDemo.cpp
//
// For more information, please see: http://www.nektar.info
//
// The MIT License
//
// Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
// Department of Aeronautics, Imperial College London (UK), and Scientific
// Computing and Imaging Institute, University of Utah (USA).
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Description: Demo for testing functionality of StdProject
//
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <LibUtilities/Polylib/Polylib.h>
#include "StdDemoSupport.hpp"
namespace po = boost::program_options;

NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff);

//Modification to deal with exact solution for diff. Return 1 if integer < 0.
static double pow_loc(const double val, const int i)
{
    return (i < 0) ? 1.0 : pow(val, i);
}

Array<OneD, NekDouble> V;
Array<OneD, NekDouble> Vd;
Array<OneD, NekDouble> Vall;
Array<OneD, NekDouble> Valldx;
Array<OneD, NekDouble> Valldy;
Array<OneD, NekDouble> V3;
Array<OneD, NekDouble> Vxm1;
Array<OneD, NekDouble> Vdxxm1;
Array<OneD, NekDouble> Vdyxm1;
Array<OneD, NekDouble> Vx1 ;
Array<OneD, NekDouble> Vdyx1;
Array<OneD, NekDouble> Vdxx1;
Array<OneD, NekDouble> Vdxy1;
Array<OneD, NekDouble> Vdyy1;
Array<OneD, NekDouble> Vy1;
Array<OneD, NekDouble> Vym1;
Array<OneD, NekDouble> Vdxym1;
Array<OneD, NekDouble> Vdyym1;

void  pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector<  NekDouble> >roots,
                          Array<OneD,NekDouble> &pqevalxast,
                          Array<OneD,NekDouble> &wsp1
                          );

            Array<OneD,NekDouble> deruhats(            Array<OneD,NekDouble> &uhats);

//declare Do_optimize
void Do_optimize(Array<OneD, NekDouble> &uhats);

//declare find_roots, flag is 0 for confederate matrix approach
vector<vector<  NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d = 0, int flag = 0);

// declare caller routine to find_roots
vector<vector<  NekDouble> > call_find_roots(Array<OneD, NekDouble> &uhatsall, int d = 0, Array< OneD, Array<OneD, NekDouble> >&uhatsedges =NullNekDoubleArrayofArray );


//declare Opt_needed
int Opt_needed(Array<OneD, NekDouble> uhats);

// find eigenvalue
vector< NekDouble> FindEigenval(vector< NekDouble > &CM,
                  int N);
                  //     Array<OneD, NekDouble> &EIG_I);//      double*EIG_R, 
//double*EIG_I);

/*Array< OneD, Array<OneD, NekDouble >  >uhatpqd(
                                        Array<OneD, NekDouble > c, 
                                        Array<OneD, NekDouble > qw, 
                                        Array<OneD, NekDouble > V,
                                        Array<OneD, NekDouble > Vd,
                                        Array<OneD, NekDouble > V3
                                                 );
*/

//declare monomial_connection
Array<OneD, Array<OneD, NekDouble> >monomial_connection(int N);

// colleague matrix
Array<OneD, Array<OneD, NekDouble> > formConf(NekDouble N);


// for 2D elements to get uhats at edges
// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,Array<OneD, Array<OneD, NekDouble> >&ret , int d = 0);

// uhatpqd stuff:
void common_code(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  Array<OneD, NekDouble> Vym1, Array<OneD, NekDouble> Vdxym1);


// Colleague matrix
Array<OneD, Array<OneD, NekDouble> > C;
StdExpansion *E;
StdExpansion *E3;
double *a;
double *b;
Array<OneD, NekDouble> qZin; //inner point grid for 2D rootfinding
Array<OneD, NekDouble> qx;
Array<OneD, NekDouble> qw;

int main(int argc, char *argv[])
{
    DemoSupport demo;
    demo.GetOptions().add_options()("optm,z", "positivity preserving optimizer");
    demo.ParseArguments(argc, argv);
    
    po::variables_map vm = demo.GetVariableMap();
    // string shape = vm["shape"].as<string>();
    
    // if(shape == "segment")
    // {
    //     dimension = 1;
    // }
/*
    po::parsed_options parsed_options = po::command_line_parser(argc, argv)
        .options(demo.GetOptions())
        .run();
    std::vector<std::vector<std::string>> lists;
    int dimension = 0;
    for (const po::option& o : parsed_options.options) {
            if (o.string_key == "order")
            {   lists.push_back(o.value);
                dimension = o.value.size();
            } 
            
        }  

    vector<PointsKey> &pkey = demo.GetPointsKey();        
    vector<BasisKey> &bkey = demo.GetBasisKey();
    cout<<"\n dimension = "<<dimension;

    for(int k = 0; k < dimension; k++)
    {
        int coeffsz = std::stoi(lists[0][k]);
        cout<<"coeffsz = "        <<coeffsz<<"\n\n";    
        pkey[k] =  LibUtilities::PointsKey (3*coeffsz, pkey[k].GetPointsType());
        bkey[k] = LibUtilities::BasisKey(bkey[k].GetBasisType(), (coeffsz),  pkey[k]);
    }*/

    //only for 1D
       
    E = demo.CreateStdExpansion();
    if (E == nullptr)
    {
        return 1;
    }
    int dimension = E->GetShapeDimension();
    std::vector<int> order;
    std::vector<BasisType> btype(3, eNoBasisType);
    LibUtilities::ShapeType stype = E->DetShapeType();
    LibUtilities::PointsType pointsTypeCheb = LibUtilities::eGaussGaussChebyshev;

    for (int i = 0; i < dimension; ++i)
    {
        btype[i] = E->GetBasisType(i);
        order.push_back(E->GetBasisNumModes(i));
    }
    cout<<"\n order[0] = "<<order[0]<<" order[1]="<<order[1]<<"\n";
    /* if(dimension > 1)
    {
        //prep for gradient descent
        // 5extra points in the interior

    LibUtilities::PointsKey  quadPointsKeyin  (order[0]+5, pointsTypeCheb);  
        qZin = (LibUtilities::PointsManager()[quadPointsKeyin])->GetZ();
    }*/


    //only for seg
    //cout<<"\n 3*order[0]-1="<<3*order[0]-1<<"\n";
    cout<<"\n C:\n";

    C = formConf(3*(3*order[0]+1));

    //C =monomial_connection(3*(3*order[0]+1)); //+1 for luck
    // print C here:
    /*cout<<"\n C:\n";
    for( int ii = 0; ii <3*( order[0]+1); ii++)
    {
        for(int jj = 0; jj< 3*(order[0]+1); jj++)
        {
            cout<<C[ii][jj]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */    
    const auto totPoints = (unsigned) E->GetTotPoints();

    Array<OneD, NekDouble> x = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> y = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> z = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dx = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dy = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dz = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> sol = Array<OneD, NekDouble>(totPoints);


    switch (dimension)
    {
        case 1:
        {
            E->GetCoords(x);
            break;
        }

        case 2:
        {
            E->GetCoords(x, y);
            break;
        }

        case 3:
        {
            E->GetCoords(x, y, z);
            break;
        }
        default:
            break;
    }

    //get solution array
    for (int i = 0; i < totPoints; ++i)
    {
        //  sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, false)-1.0;
        if(dimension ==2)
        {
        if(x[i]<=-0.2 && y[i] <=-0.2)
            sol[i] = 0;
        else sol[i] = 0.5*pow(x[i]*y[i],2);
        }
        else{
            if(x[i]<=-0.2 )
            sol[i] = 0;
        else sol[i] = 0.5*pow(x[i],2);
        }//cout<<"\nx["<<i<<"]="<<x[i];
    }

    Array<OneD, NekDouble> phys(totPoints);
    Array<OneD, NekDouble> coeffs((unsigned) E->GetNcoeffs());

    //print sol:
    /*      cout<<"\n sol:\n";
    for(int ii = 0; ii < sol.size(); ii++)
        cout<< sol[ii]<<" ";
    cout<<"\n";
    */
    //Project onto expansion
    E->FwdTrans(sol, coeffs);

    //Backward transform solution to get projected values
    E->BwdTrans(coeffs, phys);
    /*
    cout<<"\n phys:\n";
    for(int ii = 0; ii < phys.size(); ii++)
        cout<< phys[ii]<<" ";
    cout<<"\n\n";
    */

    // check for -ve values and apply opt if necessary
    if (vm.count("optm"))
    {
        int dimension = E->GetShapeDimension(); 
        LibUtilities::PointsKey pkeycheb  (totPoints, pointsTypeCheb);
        //LibUtilities::PointsType pointsTypeGGL = LibUtilities::eGaussGaussLegendre;
        //LibUtilities::PointsKey pkeyggl  (totPoints, pointsTypeGGL);
        LibUtilities::BasisKey bkeycheb(LibUtilities::eChebyshev, 3*(order[0]-1),  pkeycheb);
        
        E3 = new StdSegExp(bkeycheb);

        if (E3 == nullptr)
        {
            return 1;
        }
        Array<OneD, Array<OneD, NekDouble> > qxarr;
        qx = E3->GetBasis(0)->GetZ();
        
        qw = E3->GetBasis(0)->GetW();
        /*cout<<"\n qx\n";
        for(int kk = 0; kk < qw.size(); kk++)
            cout<<qx[kk]<<" ";
        */
        //exit(0);
        V3 = Array<OneD, NekDouble>(totPoints*(3*(order[0]-1)));
        Array<OneD, Array<OneD, NekDouble> >temp2(1);
        temp2[0] = qx;
        //E3->PhysEvalBasisGrad(temp2, V3,  NullNekDouble1DArray, NullNekDouble1DArray,  NullNekDouble1DArray);

        for(int pp = 0;  pp<(3*(order[0]-1)); pp++)
        {
            for(int yy =0; yy < qx.size(); yy++)
            {
                V3[qx.size()*pp+yy] = E3->PhysEvaluateBasis(Array<OneD, NekDouble>(1,qx[yy]), pp);
            }   
        }
        /*        cout<<"\n V3:\n";       
            for(int kk = 0; kk < V3.size(); kk++)
                cout<<V3[kk]<<" ";
            cout<<"\n";//exit(0);
        */
        if(dimension == 2 && E->GetNtraces() == 4)
        {
            int totsz = E->GetTotPoints()*E->GetNcoeffs();
          
            // populate edge root finding matrices for quadrilateral
            LibUtilities::PointsKey  quadPointsKeyin  (order[0]+5, pointsTypeCheb);
            // for gradient descent
            qZin = (LibUtilities::PointsManager()[quadPointsKeyin])->GetZ();
 
            /*qxarr[0] = Array<OneD, NekDouble>(totPoints);            
            qxarr[1] = Array<OneD, NekDouble>(totPoints);
            
            int ctr = 0;
            for(int k = 0; k < temp.size(); k++ )
            {
                
                for(int j = 0; j < temp.size(); j++)
                {
                    qxarr[0][ctr] = temp[j];
                    qxarr[1][ctr] = temp[k];
                    ctr++;
                    
                }
            }
            cout<<"\n ctr = "<<ctr<<"\n\n";
            */
            qxarr = Array<OneD, Array<OneD, NekDouble> >(dimension);
            qxarr[0] = qx;
            qxarr[1] = qx;

            // ^ was done because we need Vall, Valld, etc
            // evaluated at chebyshev points only

            //to-do: check if ptypes in E already chebyshev,
            //       then don't do the above loop

            Vall = Array<OneD, NekDouble> (qxarr[0].size()*coeffs.size()); 
            Valldx = Array<OneD, NekDouble> (qxarr[0].size()*coeffs.size());
            Valldy = Array<OneD, NekDouble>(qxarr[0].size()*coeffs.size());


            //cout<<"\n V3 sz = "<<V3.size()<< " "<<Vall.size();;
            //E->PhysEvalBasisGrad(qxarr, V, Vdx, Vdy,  NullNekDouble1DArray);

            E->PhysEvalBasisGrad(qxarr, Vall, Valldx,Valldy, NullNekDouble1DArray);

            //            qxarr[0] = Array<OneD, NekDouble>(qx.size());  
            //qxarr[0] = qx;
            //qxarr[1] = NullNekDouble1DArray;
            /*for(int kk = 0; kk < qx.size(); kk++)
                cout<<qx[kk]<<" ";
            cout<<"\n";
            */
            //both returns same: foll is easier/more efficient to do:
            //V3 = E3->GetBasis(0)->GetBdata();
            /*cout<<"\n V3:\n";       
            for(int kk = 0; kk < V3.size(); kk++)
                cout<<V3[kk]<<" ";
            cout<<"\n";
            */
            //exit(0);
            Vxm1 = Array<OneD, NekDouble>(totsz);//qx.size());//sz);
            Vdyxm1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdxxm1 = Array<OneD, NekDouble>(totsz);//sz);
            Vx1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdxx1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdyx1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdxy1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdyy1 = Array<OneD, NekDouble>(totsz);//sz);
            Vy1 = Array<OneD, NekDouble>(totsz);//sz);
            Vym1  = Array<OneD, NekDouble>(totsz);//sz);
            Vdxym1  = Array<OneD, NekDouble>(totsz);//sz);
            Vdyym1  = Array<OneD, NekDouble>(totsz);//sz);

            qxarr[1] = Array<OneD, NekDouble>(qxarr[0].size(), -1.0);
            E->PhysEvalBasisGrad(qxarr,  Vym1, Vdxym1, Vdyym1, NullNekDouble1DArray);
            /*            cout<<"\n vdyym1:\n";
            for(int kk = 0 ; kk < Vdyym1.size(); kk++)
            {
                cout<<" "<< Vdyym1[kk];
            }exit(0);
            */
            qxarr[1] = Array<OneD, NekDouble>(qxarr[0].size(), 1.0); 
            E->PhysEvalBasisGrad(qxarr, Vy1,Vdxy1,Vdyy1, NullNekDouble1DArray);

            qxarr[1] = qxarr[0];
            qxarr[0] = Array<OneD, NekDouble>(qxarr[0].size(), -1.0);
            E->PhysEvalBasisGrad(qxarr,Vxm1, Vdxxm1, Vdyxm1, NullNekDouble1DArray);

            qxarr[0] = Array<OneD, NekDouble>(qxarr[0].size(), 1.0); 
            E->PhysEvalBasisGrad(qxarr, Vx1, Vdxx1, Vdyx1, NullNekDouble1DArray);
            /*            cout<<"\n qxarr:\n";
            for(int kk = 0; kk < qxarr[1].size(); kk++)
                cout<<qxarr[1][kk]<<" ";
            */
        }
        else if(dimension == 1)
        {
            qxarr = Array<OneD, Array<OneD, NekDouble> >(dimension);
            qxarr[0] = qx;

            Vd = Array<OneD, NekDouble>(qx.size()*coeffs.size());
            V = Array<OneD, NekDouble>(qx.size()*coeffs.size());
            //V3 = Array<OneD, NekDouble>(qx.size()*coeffs.size()*3);

            E->PhysEvalBasisGrad(qxarr, V, Vd, NullNekDouble1DArray,  NullNekDouble1DArray);
      
            E3->PhysEvalBasisGrad(qxarr, V3,  NullNekDouble1DArray, NullNekDouble1DArray,  NullNekDouble1DArray);
            
        }
        //                coeffs[0] =  0.331730709814333;
        //coeffs[1] =   0.459076341659940;
        //coeffs[2] =   0.363919276512675;
        //coeffs[3] =  -0.056672051052144;
        coeffs[0] = 
            0.026888515461004; 
        coeffs[1] =  0.033343919847964;
        coeffs[2] =      0.024049819353944      ;
        coeffs[3] =  0.017735315144750 ;;
        /*        
        coeffs[0] =-0.010126840481437;
        coeffs[1] =-0.017540202233994;
        coeffs[2] =-0.022644303713790;
        coeffs[3] =-0.026793101480704;
        coeffs[4] =-0.005194577744320;
        coeffs[5] =  -0.008997272577029;
        coeffs[6] =-0.011615428950708  ;
        coeffs[7] =-0.013743560877462;
        coeffs[8] =   0.000619303315262;
        coeffs[9] =   0.001072664807330;
        coeffs[10] =   0.001384804311617;
        coeffs[11] =   0.001638522558301;
        coeffs[12] =  0.000091101178344  ;
        coeffs[13] =0.000157791869521;
        coeffs[14] =   0.000203708427607;
        coeffs[15] =   0.000241031062043;
        
                    coeffs[0] = -0.003600490035800;
        coeffs[1] = -0.003764377492043  ;
        coeffs[2] = -0.006054798699253  ;
        coeffs[3] =-0.001813736937865  ;
        coeffs[4] = -0.001519665754303  ;
        coeffs[5] = -0.001698817122805  ;
        coeffs[6] =-0.002644373952871;
        coeffs[7] = -0.001108665676515  ;
        coeffs[8] =0.000655966080148  ;
        coeffs[9] = 0.000684672455617  ;
        coeffs[10] = 0.001102181410626  ;
        coeffs[11] =0.000326846977333;
        coeffs[12] =0.000074571955782;
        coeffs[13] =0.000082199224769;
        coeffs[14] =0.000128822914434;
        coeffs[15] =0.000050772186786;
        */                      
        if(Opt_needed(coeffs))
        {

            cout<<"\n need optimization\n\n";
            
            Do_optimize(coeffs);
            
            cout<<"\n doopt done\n verifying...\n";//exit(0);
            cout<<"\n do_opt returning uhats\n";
            for(int ii = 0; ii < coeffs.size(); ii++)
                cout<<coeffs[ii]<<" ";
            cout<<"\n";
            if(Opt_needed(coeffs))
            {
                cout<<"\n fail\n\n";
                exit(0);
            }
            else
            {
                cout<<"\n pass\n\n";exit(0);
            }
        }
        else{
            cout<<"\n optimizer no need\n\n";
        }
        //Backward transform solution to get projected values
        E->BwdTrans(coeffs, phys);

    }

    

    /*if (vm.count("diff"))
    {
        for (int i = 0; i < totPoints; ++i)
        {
            sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, true);
        }
    }*/

    //Calculate L_inf & L_2 error
    cout << "L infinity error: \t" << E->Linf(phys, sol) << endl;
    if (stype != ePoint)
    {
        cout << "L 2 error: \t \t \t" << E->L2(phys, sol) << endl;
    }

    if (!vm.count("diff") && stype != ePoint)
    {
        //Evaluate solution at x = y = 0 and print error
        Array<OneD, NekDouble> t = Array<OneD, NekDouble>(3);
        t[0] = -0.5;
        t[1] = -0.25;
        t[2] = -0.3;
        sol[0] = Shape_sol(t[0], t[1], t[2], order, btype, stype, false);

        NekDouble nsol = E->PhysEvaluate(t, phys);

        cout << "Error at x = (";
        for (int i = 0; i < dimension; ++i)
        {
            cout << t[i] << ", ";
        }
        cout << "\b\b): " << nsol - sol[0] << endl;
    }

    // Calculate integral of known function to test different quadrature
    // distributions on each element.
    for (int i = 0; i < totPoints; ++i)
    {
        sol[i] = dimension == 1 ? exp(x[i]) : dimension == 2 ?
            exp(x[i]) * sin(y[i]) : exp(x[i] + y[i] + z[i]);
    }

    NekDouble exact = 0.0;
    switch(stype)
    {
        case eSegment:
            exact = M_E - 1.0 / M_E;
            break;
        case eTriangle:
            exact = -0.5 * (sin(1.0) + cos(1.0) + M_E * M_E *
                            (sin(1.0) - cos(1.0))) / M_E;
            break;
        case eQuadrilateral:
            exact = 2.0 * (M_E - 1.0 / M_E) * sin(1.0);
            break;
        case eTetrahedron:
            exact = 1.0 / M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePrism:
            exact = M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePyramid:
            exact = - 1.0 / M_E / M_E / M_E - 4.0 / M_E + M_E;
            break;
        case eHexahedron:
            exact = pow((M_E * M_E - 1.0) / M_E, 3.0);
            break;
        default:
            ASSERTL0(false, "Exact solution not known.");
            break;
    }
    std::cout << "Integral error: " << fabs(exact - E->Integral(sol))
              << std::endl;

    return 0;
}

// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,    Array<OneD, Array<OneD, NekDouble> >&ret , int d)
{
    int numedges = ret.size();
    int modes = E->GetNcoeffs();
    int modes1D = 3*(E->GetBasis(0)->GetNumModes()-1);
    
    int totpts = E->GetTotPoints();
    // bot edge = 0, y = -1
    // right edge = 1, x = 1
    // top edge = 2, y = 1
    // left edge = 3, x = -1
    
    
    // assert d = 0 or 1
    //if(d == 1)
    //{
        //to-do assert that numedges = 3 or 4
    if(numedges == 4) //quadrilateral
    {
        
        /*        cout<<"\n all uhats:\n";
        for(int kk = 0 ; kk < uhats.size(); kk++)
        {
            cout<<uhats[kk]<<" ";
            }*/
        
        //normal projection of der of uhats on quad edges
        if(d == 0) //quadrilateral
        {  
            ret[0] = Array<OneD, NekDouble>(modes);        
            ret[1] = Array<OneD, NekDouble>(modes);
            ret[2] = Array<OneD, NekDouble>(modes);
            ret[3] = Array<OneD, NekDouble>(modes);
        

            Array<OneD, NekDouble> vals(totpts);//Vym1.size());
            Array<OneD, NekDouble> temp(totpts);
            
            //V*vals*qwmore
            
            /*
              cout<<"\n vals "<<":";
              for(int p = 0; p < vals.size(); p++)
              cout<<" "<<vals[p];*/
            //            cout<<"\n bot edge uhats:\n";
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(totpts, &Vdxym1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, &Vdyym1[k], totpts, &uhats[0], 1, &temp[0], 1);
                Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[0][k] = Vmath::Vsum(vals.size(), vals, 1);
                //  cout<<" "<<ret[0][k];
            }        
            //                cout<<"\n right edge uhats:\n";
            //Vmath::Vmul(modes1D, &Vx1[0], 1, &qw[0], 1, &vals[0], 1);
            for(int k = 0; k < modes; k++)
            {    

                Vmath::Vmul(totpts, &Vdxx1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, &Vdyx1[k], totpts, &uhats[0], 1, &temp[0], 1);
                Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[1][k] = Vmath::Vsum(vals.size(), vals, 1);

            }        
            
            //cout<<"\n top edge uhats:\n";
            //            Vmath::Vmul(modes1D, &Vy1[0], 1, &qw[0], 1, &vals[0], 1);
            for(int k = 0; k < modes; k++)
            {    
                
                Vmath::Vmul(totpts, &Vdxy1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, &Vdyy1[k], totpts, &uhats[0], 1, &temp[0], 1);
                Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[2][k] = Vmath::Vsum(vals.size(), vals, 1);
                //cout<<" "<<ret[2][k];
            }        
            //cout<<"\n left edge uhats:\n";
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(totpts, &Vdxxm1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, &Vdyxm1[k], totpts, &uhats[0], 1, &temp[0], 1);
                Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
      
                Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[3][k] = Vmath::Vsum(vals.size(), vals, 1);
                //cout<<" "<<ret[3][k];
            }                
            
        }
        
        else // d = 1 so project der to 1D 3*N space
        {
            // uhatpqd stuff:
            //pqeval = -(sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c) + (sum(Vxm1.*Vxm1, 2)).*(Vd*c);

            ret[0] = Array<OneD, NekDouble>(modes1D);        

            ret[1] = Array<OneD, NekDouble>(modes1D);
            ret[2] = Array<OneD, NekDouble>(modes1D);
            ret[3] = Array<OneD, NekDouble>(modes1D);
        
            
            // bot edge
            common_code(uhats, ret[0], Vym1, Vdxym1);
            // right edge
            common_code(uhats, ret[1], Vx1, Vdyx1);
            // top edge
            common_code(uhats, ret[2], Vy1, Vdxy1);
            // left edge
            common_code(uhats, ret[3], Vxm1, Vdyxm1);
        }
    }
    else if(numedges == 1)
    {
        if(d == 1) // so project der to 3*N space
        {
            ret[0] = Array<OneD, NekDouble>(modes1D);        
            
            common_code(uhats, ret[0], V, Vd);
            
        }
        else
        {
            ret[0] = uhats;
        }
    }
    else //triangle
    {//cout<<"\n edges = "<<numedges<<" d = "<<d<<"\n";
        cout<<"\n coming soon...3\n";
    }
        
}

void common_code(Array<OneD, NekDouble> &uhats, Array<OneD, NekDouble> &ret,  Array<OneD, NekDouble> Vym1, Array<OneD, NekDouble> Vdxym1)
{

    int modes = E->GetNcoeffs();
    int totpts = E->GetTotPoints();
    
    Array<OneD, NekDouble> temp(totpts), temp1(totpts);
    Array<OneD, NekDouble> temp2(totpts);
    Array<OneD, NekDouble> temp4(totpts);
    int ctr=0;
    // edge = 0 is bot
    for(int i = 0; i<modes; i++, ctr++)
    {
        Vmath::Vmul(totpts, &Vym1[0]+i, totpts, &Vdxym1[0]+i, totpts, &temp2[0], 1);
        
        NekDouble v1  = Vmath::Vsum(totpts, temp2, 1);  
        temp[ctr] = v1;
        Vmath::Vmul(totpts, &Vym1[i], totpts, &uhats[0], 1, &temp2[0], 1);
        v1  = Vmath::Vsum(totpts, temp2, 1);  
        temp4[ctr] = temp[ctr]*v1;
        

        // At this point,                 
        // temp = (sum(Vxm1.*Vdxm1, 2)).*(Vxm1*c)

        Vmath::Vmul(totpts, &Vym1[0]+i, totpts, &Vym1[0]+i, totpts, &temp2[0], 1);
        
        v1  = Vmath::Vsum(totpts, temp2, 1);  
        temp1[ctr] = v1;
        
        Vmath::Vmul(totpts, &Vdxym1[i], totpts, &uhats[0], 1, &temp2[0], 1);
        v1  = Vmath::Vsum(totpts, temp2, 1);  
        temp4[ctr] = -temp4[ctr] +  temp1[ctr]*v1;
        
        /*        cout<<"\n V3 here:";
        for(int kk = 0 ; kk < V3.size(); kk++)
            cout<<V3[kk]<<" ";
            cout<<"\n";
        */
        // At this point,
        // temp1 = (sum(Vxm1.*Vxm1, 2)).*(Vd*c)


        /*        cout<<"\n tqmp1 here:";
        for(int kk = 0 ; kk < temp1.size(); kk++)
            cout<<temp1[kk]<<" ";
        cout<<"\n";
        
        temp2[ctr] = temp1[ctr] - temp[ctr];
        cout<<"\n tqmp2 here:";
        for(int kk = 0 ; kk < temp2.size(); kk++)
            cout<<temp2[kk]<<" ";
        cout<<"\n";
       */
        
    }
    // at this point,
    // temp2 is pqeval

    //uhat = (V3)*(wa.*); //pqeval = temp
    Vmath::Vmul(totpts, qw, 1, temp4, 1, temp4, 1);

    //cout<<"\n pqeval here:";
    /*    for(int kk = 0 ; kk < temp4.size(); kk++)
            cout<<temp4[kk]<<" ";
        cout<<"\n";
    */
    //cout<<"\n here edge 0:\n";
        //cout<<"\n V3 sz = "<<V3.size()<<" modes="<<modes<<" totpts="<<totpts<<"3*E->GetBasis(0)->GetNumModes()="<<3*E->GetBasis(0)->GetNumModes()<<"\n";

    //V3*temp2
    for(int i = 0; i<3*(E->GetBasis(0)->GetNumModes()-1); i++)
    {
        Vmath::Vmul(totpts, &V3[i*totpts], 1, &temp4[0], 1, &temp4[0], 1);
        ret[i] = Vmath::Vsum(totpts, temp4, 1);  
        //cout<<ret[i]<<" ";

    }
    //    exit(0);

    
}

Array<OneD, Array<OneD, NekDouble> > formConf(NekDouble N)
{
    int evalPts = N+1; //+1 for luck
    int i, j;       
    Nektar::Array<Nektar::OneD, Nektar::NekDouble> ab1(evalPts);
    Nektar::Array<Nektar::OneD, Nektar::NekDouble> ab2(evalPts);
    Polylib::RecCoeff(evalPts, &ab1[0], &ab2[0], -0.5, -0.5);
    // Form confederate matrix

    /*cout<<"\n abcheb:\n";
      for(int yy = 0; yy<ab1.num_elements(); yy++)
        {
        cout<<ab1[yy]<<" ";
          }
          cout<<"\n";
            for(int yy = 0; yy<ab2.num_elements(); yy++)
              {
              cout<<ab2[yy]<<" ";
                }
                cout<<"\n";
                  
                cout<<"\n";
    */
  
    // a = 2*a
    // b = 2*b
    Vmath::Smul(ab1.size(), 2.0, ab1, 1, ab1, 1);
    Vmath::Smul(ab2.size(), 2.0, ab2, 1, ab2, 1);

    //  J = full(spdiags([[b(3:n);0.5;0] a(1:n) b(1:n)], -1:1, n, n));
    vector<vector<NekDouble> > J;//, Array<OneD, NekDouble>(N,0.0));
      
    vector<NekDouble> row(N);
    NekDouble tt = ab1[0];
    row[0] = tt;
    tt = ab2[1];
    row[1] = tt;
    J.push_back(row);
    for(i = 1; i < N-1; ++i)
    {
        vector<NekDouble> row(N,0.0);
        for(j = 1; j < N-1; ++j)
        {
            if( i == j)
            {
                NekDouble t1 = ab1[i];
                NekDouble t2 = ab2[i+1];
                NekDouble t3 = ab2[i];
                row[j] = t1;
                row[j+1] = t2;
                row[j-1] = t3;
            }
        }
        J.push_back(row);
    }
      
    vector<NekDouble> rowN(N);
    tt = ab1[N-1];
    rowN[N-1] = tt;
    tt = ab2[N-1];
    rowN[N-2] = tt;
    J.push_back(rowN);
      
    //print J:
    
    //cout<<"\n J:\n";
            for(int yy = 0; yy<J.size(); yy++)
            {
            for(int uu  = 0 ; uu<J[0].size(); uu++)
            {
                J[yy][uu] = J[yy][uu]/2;
            }
            //      cout<<"\n";
            }
            //cout<<"\n";
            /*        exit(0);
    */
    Array<OneD, Array<OneD, NekDouble> > C(J.size());
    for(i = 0; i < J.size(); i++)
    {
        C[i] = Array<OneD, NekDouble>(J[i].size(),J[i].data());
        //  Vmath::Vcopy(J[i].size(), , 1, C[i], 1);
    }
    //cout<<"\n\n";
    //print C:
    // cout<<"\n C:\n";
    // for(int yy = 0; yy<C.num_elements(); yy++)
    //   {
    // for(int uu  = 0 ; uu<C[00].num_elements(); uu++)
    //   {
    //     cout<<C[yy][uu]<<" ";
    //   }
    // cout<<"\n";
    //   }
    // cout<<"\n";
      
    return C;
}

vector<vector<  NekDouble> > call_find_roots(Array<OneD,  NekDouble> &uhats , int d, Array<OneD, Array<OneD, NekDouble> >&uhatsedges)
{
    boost::ignore_unused(d);
    int dimension = E->GetShapeDimension(); 
    vector<vector< NekDouble> > ret(dimension);

    if(dimension == 1 )
    {
        //   Array<OneD, NekDouble> uhatd(V3.size());
        //DoProjectpq( uhatd, uhats, V, Vd);

        //for(int kk = 0; kk < uhats.size(); kk++)
        //    cout<<uhats[kk]<<" ";
        ret = find_roots(uhats, 1);
        //        for(int kk = 0; kk < ret[0].size(); kk++)
        //    cout<<ret[0][kk]<<" ";                 
    }
    else if(dimension == 2)
    {
        //cout<<"\n    uhatsedges:";
        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();


        // to-do: assert 2D elements allowed numedges = 3 or 4
        if( numedges == 4)
        {
            // for 2D, structure of roots vector:
            // row 0 vector = left edge
            // row 1 vector = right
            // row 2 vector = top
            // row 3 vector = bot
            // row 4 vector = {x1,x2} inner root
            
            
            
            for(int ii = 0; ii < numedges; ii++)
            {
                vector<vector<NekDouble> > tmp;
            
                //cout<<"\n ii = "<<ii<<"\n\n";
                //cout<<" uhatsedges = "<<uhatsedges.size()<<" "<<uhatsedges[ii].size()<<"\n\n";
                // size of tmp will be dim \times no. of roots
                if(abs(Vmath::Vmin(uhatsedges[ii].size(),uhatsedges[ii],1)) > 1e-9)
                {    
                    //cout<<"\n in\n\n";
                    tmp  = (find_roots(uhatsedges[ii], 0, 0)) ;
                }else
                {

                    // cout<<"\n else\n\n";
                    break;
                }
                //print tmp:
                /*    for(int k = 0; k < tmp.size(); k++)
                {
                    for(int p = 0; p < tmp[0].size(); p++)
                    {
                        cout<<" " <<tmp[k][p]<<" ";
                    }
                    cout<<"\n";
                    }*/
                for(int p = 0; p < tmp[0].size(); p++)
                {

                    if(ii == 0) // bot edge
                    {
                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(-1);
                        
                    }else if(ii == 1) // right edge
                    {
                        ret[0].push_back(1);
                        ret[1].push_back(tmp[0][p]);
                    }else if(ii == 2) // top edge
                    {
                        ret[0].push_back(tmp[0][p]);
                        ret[1].push_back(1);
                    
                    
                    }else //if(ii == 3) // left edge
                    {
                        ret[0].push_back(-1);
                        ret[1].push_back(tmp[0][p]);
                    }
                    
                }
                // only for 3D
                //ret[2].push_back(row[2]);
                
            }
            
        }
        else
        {
            // triangle edge roots code
            cout<<"\n coming soon...1\n\n";
        }
        
        //find interior roots:
        vector<vector<NekDouble> > tmp = (find_roots(uhats, 0, dimension)) ;
        ret[0].push_back(tmp[0][0]);
        ret[1].push_back(tmp[0][1]);
        
        
    
    }
    else //3D
    {
        cout<<"\n coming soon....2\n";
    }
    return ret;
}


// Called by call_find_roots depending on edges or interior region 
// rootfinding
// d=1 :: derivatives
// flag = 0, edges (1D rootfinding using confederate matrix)
// flag = 1, interior region rootfinding using gradient descent
vector<vector<NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d, int flag)
{
    int dim = E->GetShapeDimension();
    // to-do assert dimension is 1 2 or 3
    vector<vector< NekDouble> > ret(dim);
    /*    cout<<"\n in findroots\n\n";
    for(int kk = 0; kk < uhats.size(); kk++)
        cout<<uhats[kk]<<" ";
    */
    
    //Confederate matrix approach
    if(dim == 1 || flag == 0)
    {
        int N = uhats.size();
        //cout<<"\n N = "<<N<<"\n\n";
        vector<NekDouble> uhatsmon;
        while(abs(uhats[N-1])<1e-8)
        {
            //cout<<"N = "<<N<<"\n";
            N = N-1;
        } 
        vector<NekDouble> temp(N);
        
        // convert uhats to monomial, find roots of uhats or der of uhats
        // uhatsmon = C(1:numModes,1:numModes)'*uhats;
        
        //cout<<"N = "<<N<<" C sz = "<<C.size()<<" "<<C[0].size()<<"\n";
        
        for(int k = 0; k < N; k++)
        {
            for(int jj= 0 ; jj < N; jj++)
            {
                //cout<<C[jj][k]<<" ";
                temp[jj ] = C[jj][k];
            }
            //cout<<"\n";
            Vmath::Vmul(N, &temp[0], 1,  &uhats[0], 1, &temp[0], 1);
            uhatsmon.push_back(Vmath::Vsum(N, &temp[0], 1));
            //        cout<<"uhatsmon["<<k<<"]="<<uhatsmon[k]<<" \n";
        }

        //cout<<"\n  d = "<<d<<"\n\n";;
        N = uhatsmon.size();
     

        // truncate trailing zeros
        
        // now size of uhatsmon = N;
        //    Array<OneD, NekDouble> uhatsdiff;
        vector<NekDouble> uhatsdiff;
        // if d == 1, 
        
        if(d == 1)
        {
            for(int k = 1; k < N; k++)
            {
                uhatsdiff.push_back(k*uhatsmon[k]);
            }
            N = N-1;
            
        }
        else //d == 0
        {
            uhatsdiff = uhatsmon;
            
        }
        //        cout<<"\n N new = "<<N;
        Vmath::Smul(N, 1.0/uhatsdiff[N-1], &uhatsdiff[0], 1, &uhatsdiff[0], 1);
        vector<NekDouble> EIG_R = FindEigenval(uhatsdiff, N);
        //cout<<"\n print done after eigenvals eig_r = "<<EIG_R.size()<<"\n\n";
        
        for(int kk = 0; kk <EIG_R.size(); kk++)
        {
            ret[0].push_back( EIG_R[kk] );
        }
    }
    else if(dim == 2)
    {
        
        // Gradient descent
        //        cout<<"\n gradient descent\n\n";
        
        // convert uhats->deruhats
        Array<OneD, NekDouble> uhatder = deruhats(uhats);

        // Assert that d = 0
        // Gradient descent
        //cout<<"\n gradient descent\n";
        int num = uhatder.size(); 
        Array<OneD, NekDouble> temp(num);
        std::vector< std::vector<NekDouble> > R;
        Array< OneD, NekDouble> xast(2);
        //xast[0] = Array<OneD, NekDouble>(1); 
        //xast[1] = Array<OneD, NekDouble>(1);
        Array<OneD, NekDouble>Jg(2);
        Array<OneD, NekDouble> g(2);
        Array<OneD, NekDouble> evald0(num);
        Array<OneD, NekDouble> evald1(num);
        
        int ii,jj,kk, ctrn = 0;
        NekDouble epsl = 1.0, xs1 = 0, ys1 = 0;
        NekDouble x1, x2;
        int nmpt = E->GetTotPoints();
        for(ii = 0; ii < qZin.size(); ++ii)
        {
            for(jj = 0; jj < qZin.size(); ++jj)
            {
                x1 = qZin[ii], x2 = qZin[jj];
                //Array<OneD,NekDouble> x1a(1,x1);
                //Array<OneD,NekDouble> x2a(1,x2);
                xast[0] = x1;
                xast[1] = x2;
                //NekMatrix<NekDouble>      Vd1 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0, 0,0);
                
                //ptr->PhysEvalBasisGradFast(xast, NullNekDouble1DArray, evald0, evald1);      
                for(kk = 0; kk < num; kk++)
                {
                    evald0[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[1][nmpt*kk])); 
                    evald1[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[2][nmpt*kk])); 
                }
                Vmath::Vmul(num, &evald0[0], 1, &uhatder[0], 1, &temp[0], 1);
                g[0] = Vmath::Vsum(num, temp, 1);                   
                //cout<<"\ng[0]="<<g[0]<<"\n\n";;
                Vmath::Vmul(num, &evald1[0], 1, &uhatder[0], 1, &temp[0], 1);
                g[1] = Vmath::Vsum(num, temp, 1);                                      
                if(epsl > (abs(g[0]) + abs(g[1])))
                {
                    epsl = abs(g[0])+abs(g[1]);
                    xs1 = x1;
                    ys1 = x2;
                }
                ctrn++;
            }
        }
        
        int n = 0;
        x1 = xs1, x2 = ys1;
        //            cout<<"\n x1 = "<<x1<<" x2 = "<<x2<<"epsl = "<<epsl<<"\n\n";
        epsl = 1.0;
        
        Array<OneD,NekDouble> x1a(1), x2a(1);
        NekDouble stepsize = 1e-3, x1new = x1, x2new = x2, iter = 100;
        // loop for gradient descent 2D:
        while(epsl > 1e-11 && n < iter)
        {
            if(abs(x1new)<1e-12)
                x1new = 0.0;
            if(abs(x2new)<1e-12)
                x2new = 0.0;
            xast[0] = x1new;
            xast[1] = x2new;
            for(kk = 0; kk < num; kk++)
            {
                
                evald0[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[1][nmpt*kk])); 
                evald1[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[2][nmpt*kk])); 
                    
            }

            
            //print evald0:
            //cout<<"\n N = "<<N<<"\n";
            //cout<<"\n evald0:\n";
            //for(int ii = 0; ii<evald0.size(); ii++)
            //    cout<<" "<<evald1[ii];
            //cout<<"\n";
            //x1a[0] =x1new;//Array<OneD,NekDouble>(1,x1);
            //x2a[0] = x2new;//Array<OneD,NekDouble> x2a(1,x2);
            
            //                Vd1 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0,1 ,0);
            
            //print Vd1:
            //cout<<"\n Vd1:\n";
            //for(int ii = 0; ii<Vd1.GetColumns(); ii++)
            //    cout<<" "<<Vd1(0,ii);
            //cout<<"\n\n";
            
            
            Vmath::Vmul(num, &evald0[0], 1, &uhatder[0], 1, &temp[0], 1);
            //Vmath::Vmul(num, &Vd1.GetPtr()[0], 1, &uhats[0], 1, &temp[0], 1);
            
            g[0] = Vmath::Vsum(num, temp, 1);
            //x1a[0] = x1;
            //x2a[0] = x2;
            //Vd2 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0,0 ,1);
            
            Vmath::Vmul(num, &evald1[0], 1, &uhatder[0], 1, &temp[0], 1);
            // Vmath::Vmul(num, &Vd2.GetPtr()[0], 1, &uhats[0], 1, &temp[0], 1);
            g[1] = Vmath::Vsum(num, temp, 1);
            
            epsl = abs(g[0])+abs(g[1]);
            x1new = x1 - stepsize*(g[0]);
            x2new = x2 - stepsize*(g[1]);
            //              cout<<"\n g[0] = "<<g[0]<<" g[1]="<<g[1]<<" epsl="<<epsl<<"x1 = "<<x1<<"x1new="<<x1new<<"n = "<<n<<"\n\n"; 
            if(x1new - x1 <1e-10 && x2new - x2<1e-10)
            {break;}
            
            if(abs(x1new)>1.0)
            {
                x1new = x1;
            }
            if(abs(x2new)>1.0)
            {
                x2new = x2;
            }
            
            n = n+1;
        }
        //cout<<"\n x1 = "<<x1<<"\t y1 = "<<x2<<"\n\n";
        //check
        if(abs(x1)<=1.0 && abs(x2)<=1.0)
        {
            ret[0].push_back(x1);   
            ret[1].push_back(x2);   
        }
    }
    else{
        
        cout<<"\n Dimension 3 coming soon...\n";
    }
    //cout<<"\n ret from find_roots ret ="<<ret.size()<<"\n\n";
    return ret;    

}
    
    
Array<OneD, Array<OneD, NekDouble> > monomial_connection(int N)
{

    Array<OneD, Array<OneD, NekDouble> > R(N);
    a = new double[N];
    b = new double[N];    


    // Initialize a and b to zero
    for(int i = 0; i < N; i++)
    {
        a[i] = 0.0;
        b[i] = 0.0;
    }
    
    // [a,b] = jacobi_recurrence(maxN+1, 0, 0);
    
    Polylib::RecCoeff(N, a, b, 0.0, 0.0);
    //cout<<"\n a and b:\n";
    
    
    //     assert( (N >= numel(a)) && (N >= numel(b)) );

    //b = sqrt(b)
    transform(b, b+N, b, (double(*)(double)) sqrt);
    //b = 1./b
    Array<OneD, NekDouble> r(N, b);
    for(int i = 0; i<r.size(); i++)
    {
        r[i] = 1/r[i];
    }

   // local_leading_coeffs = cumprod(1./b);

    //r = cumprod(1./b) 
    partial_sum (r.begin(), r.end(), r.begin(), multiplies<double>());

    /*    cout<<"\n r:\n";
for(int i = 0; i<N; i++)
    {
        cout<<r[i]<<" ";   
        }*/

    //Build the connection matrix for this dimension and then distribute it accordingly

    for(int i = 0; i<N; i++)
    {
        Array<OneD, NekDouble> row(N);
        for(int j = 0; j<N; j++)
        {
            if( i == j)
            {
                row[i] = r[i];
            }

        }
            R[i] = row;

    }

    //print R:
    /*    cout<<"\n R=\n";
    for(int i = 0; i<N; i++)
    {
        for(int j = 0; j<N; j++)
        {
            cout<<R[i][j]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */
    for(int i = 1; i<N; i++)
    {
        //"side" conditions (i.e. those w/o left/right boundary points)
        if(i<2)
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0]);
        }
        else
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0] - b[i-1]*R[i-2][0]);
            
            //All the rest are `vectorizable'
            for(int j = 1; j<i-1; j++)
            {
                R[i][j] = R[i-1][j-1] - a[i-1]*R[i-1][j] - b[i-1]*R[i-2][j];
                R[i][j] = R[i][j]/b[i];
            }
            
        }
    }
    /*  Array<OneD, Array<OneD, NekDouble> > Rtrans(R);
    for(int i = 0; i < R.size(); i++)
    {
        for(int j = 0; j < R[0].size(); j++)
        {
            Rtrans[i][j] = R[j][i];
        }
    } */

    return R;

}

// convert uhats -> uhats of der of function
            Array<OneD,NekDouble> deruhats(            Array<OneD,NekDouble> &uhats)
{
    int modes = E->GetNcoeffs();
    int totpts = E->GetTotPoints();
    Array<OneD, NekDouble> vals(totpts), temp(totpts), hold(modes);
    
    for(int k = 0; k < modes; k++)
    {    
        
        // uhatsnew = V'*w*(Vdx*uhats+Vdy*uhats)
        Vmath::Vmul(totpts, &Valldx[k], totpts, &uhats[0], 1, &vals[0], 1);
        Vmath::Vmul(totpts, &Valldy[k], totpts, &uhats[0], 1, &temp[0], 1);
        Vmath::Vadd(totpts, &vals[0], 1, &temp[0], 1, &vals[0], 1);
        Vmath::Vmul(totpts, qw, 1, vals, 1, vals, 1);
        Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
        hold[k] = Vmath::Vsum(vals.size(), vals, 1);
        
    }
    return hold;
}

vector< NekDouble> FindEigenval( vector<NekDouble> &uhatsdiff,
                   int N) 
{    
    boost::ignore_unused(N);
    int sizemat = uhatsdiff.size();
    Array<OneD, NekDouble> CMdiff(pow(sizemat-1,2),0.0);

//cout<<"\n cmdiff size = "<<CMdiff.size()<<"\n\n";
// Form companion matrix for maxima/minima
// CMdiff = eye(length(uhatsdiff)-2);
// and
    // CMdiff = [CMdiff -uhatsdiff(2:end-1)];
    // and
    // CMdiff = [[zeros(1,length(uhatsdiff)-2) -uhatsdiff(1)]; CMdiff];

/*for(int k = 0; k <sizemat; k++)
    {
        cout<<uhatsdiff[k]<<" ";
    }
cout<<"\n\n";*/
    for(int k = 1; k < sizemat-1; k++)
    {
        
        CMdiff[(k)*(sizemat-1) +k-1] = 1.0;
        CMdiff[(k+1)*(sizemat-1)-1 ] = -uhatsdiff[k];
    }    

    
    //CMdiff[0] = temp1;
    //temp1[N-2] = -uhatsdiff[0];
    //Vmath::Vcopy(N-1, &temp1[0], 1, &CMdiff[0][0], 1);
    //    CMdiff[0][uhatsdiff.size()-2] = -uhatsdiff[0];
    CMdiff[sizemat-2] = -uhatsdiff[0]; 

    const int sz = sizemat-1;//pow(CMdiff.size(),0.5);
    Array<OneD, NekDouble> Mat(sz*sz,0.0);
    const int  lwork = 3*(sz);

    Array<OneD, NekDouble> work1(lwork), EIG_temp(sz), EIG_I(sz);
    //    NekDouble *work1[lwork];
    //NekDouble *EIG_temp[sz];
    //NekDouble *EIG_I[sz];

    //cout<<"\n\n CMdiff=\n";
 
   //print CMdiff transpose
        for(int ii = 0; ii<CMdiff.size(); ii++)
    {
        {
            //      cout<<CMdiff[ii]<<" ";
            
        }
    }
        //    cout<<"\n\nMat=";

    //print CMdiff transpose
    for(int ii = 0; ii<sz; ii++)
    {
        for(int jj = 0; jj<sz; jj++)
        {   
            {
                Mat[ii*(sizemat-1)+jj] = CMdiff[jj*(sizemat-1)+ii];
          
            }
        }
    }
    /*    cout<<"\n\n Mat=\n";
    
   //print CMdiff transpose
        for(int ii = 0; ii<sz*sz; ii++)
    {
        {
            cout<<Mat[ii]<<" ";
            
        }
    }
    cout<<"\n\n";
    */
    int info = 0;
    
    
    char jobvl = 'N';
    char jobvr = 'N';

    NekDouble dum1, dum2;
    
    Lapack::Dgeev(jobvl,jobvr,sz,Mat.get(),sz,EIG_temp.get(),EIG_I.get(),&dum1,1,&dum2,1,&work1[0],lwork,info);
   
    vector<NekDouble>EIG_R;// (ctr, EIG_temp.data());
    
    for(int k = 0; k < sz; k++)
    {
        //cout<<"\n"<< EIG_temp[k]<<" "<<EIG_I[k];
        if(abs(EIG_I[k])<1e-8 && abs(EIG_temp[k])<=1.0)
        {
            EIG_R.push_back(EIG_temp[k]);
        }
    }
    
    EIG_R.push_back(-1.0);
    EIG_R.push_back(1.0);

    //cout<<"\n eigenvals\n:";

    //for(int ii = 0; ii < EIG_R.size(); ii++)
        //    cout<<EIG_R[ii]<<" ";
    //    cout<<"\n print done\n\n";
    //cout<<"\n print done: EIG_R:"<<EIG_R[0]<<" "<<EIG_R[1]<<"\n\n";

    return EIG_R;
}

int Opt_needed(Array<OneD, NekDouble> uhats)
{

    //    Array<OneD, NekDouble> uhats = E->GetCoeffs();

    
    int dimension = E->GetShapeDimension();

    int totModes = uhats.size();
    vector<vector<  NekDouble> > roots;
    /*  cout<<"\n uhats in opt_needed:"<<uhats.size()<<"\n";
    for(int ii = 0; ii<uhats.size(); ii++)
    {
        cout<<uhats[ii]<<" ";
    }
    cout<<"\n\n";
*/
    if( dimension == 2)
    {
        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();
        Array<OneD, Array<OneD, NekDouble> > edgeuhats  (numedges);

        project_edges(uhats, edgeuhats);

        //        cout<<"\n edgeuhats = "<<edgeuhats.size()<<"\t"<< edgeuhats[0].size();
        //find roots of der of uhats, that is why d = 0
        roots = call_find_roots(uhats, 0, edgeuhats);

        /*       cout<<"\n back! roots = "<<roots.size()<<" "<<roots[0].size()<<"\n\n";
        for(int k = 0; k<roots.size(); k++)
        {
            for(int p=0; p<roots[0].size(); p++)
            {
                cout<<" "<<roots[k][p];
            }
            cout<<"\n";
            }cout<<"\n\n";exit(0);*/

    }
    else if(dimension == 1)
    {
        // find roots of der of uhats, that is why d = 1
        roots = call_find_roots(uhats, 1);
        //cout<<"\n roots sz ="<<roots.size()<<"\n\n";
        // print roots:
        /*cout<<"\n roots in opt_needed seg:\n";
        for(int ii = 0; ii<roots.size(); ii++)
              {
                  for(int jj = 0; jj<roots[0].size(); jj++)
                  {
                      cout<<roots[ii][jj]<<" ";
                  }
                  cout<<"\n";
              }
              cout<<"\n";
        */    
        // if vector[0].size() is 1, dim = 1...
        
        // convert roots vec to array
        
        
    }   

    Array<OneD, Array<OneD,  NekDouble> > rootsarr(roots.size());
        
        
        for(int ii = 0; ii < roots.size(); ii++)
        {
            rootsarr[ii] = Array<OneD, NekDouble>(roots[ii].size(), roots[ii].data());
        }
 
    // evaluate ortho basis at roots
    // evalBasisRoots is flattened basis eval matrix
    int     evalsz = (roots[0].size())*totModes;
    Array<OneD, NekDouble> evalBasisRoots(evalsz);
 
    E->PhysEvalBasisGrad(rootsarr, evalBasisRoots, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
  
   Array<OneD, NekDouble> tmp(roots.size());
    
    /*    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        for(int jj = 0; jj <totModes; jj++)
        {
            //            cout<<"\n diededede ii = "<<ii<<"jj = "<<jj<<"roots[0].size()="<<roots[0].size()<<" evlbasroots sz="<<evalBasisRoots.size()<<" totmodes = "<<totModes<<" jj + roots[0].size()*ii = "<<jj + roots[0].size()*ii<<"\n\n";

            for(int kk = 0; kk < roots.size(); kk++)
            {
                tmp[kk] = roots[kk][ii];
            }
            evalBasisRoots[jj + roots[0].size()*ii] = (E->PhysEvaluateBasis(tmp, jj));
        }
    }*/
    

    // vals = evalBasisRoots \times uhats 
    cout<<"\n in opt_needed\n";
    Array<OneD, NekDouble> vals(roots[0].size()), temp(totModes);
    for(int k = 0; k < vals.size(); ++k)
    {

        Vmath::Vmul(totModes, &evalBasisRoots[k], vals.size(), &uhats[0], 1, &temp[0], 1);
        vals[k] = Vmath::Vsum(temp.size(), temp, 1);
        cout<<" ("<<roots[0][k]<<" "<<//roots[1][k]<<
            " )="<<vals[k]<<" ";
    }
 
    NekDouble minv = Vmath::Vmin(vals.size(), vals, 1);	
    int idx = Vmath::Imin(vals.size(), vals, 1);

    cout<<"\n minv = "<<minv<<" at "<<roots[0][idx]<<" "<<//roots[1][idx]<<
        "\n\n";
    
    if(minv < 0.0 && abs(minv)>1e-10)
    {
        return 1;
    }
    return 0;
}

void pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector< NekDouble> > roots,
                          Array<OneD,NekDouble> &pqevalxast,
                          Array<OneD,NekDouble> &wsp1)
{

    int N = uhats.size();
    vector< NekDouble> V1;
    vector<NekDouble> Vsumsq, fvals;//(roots[0].size());
    int dim = E->GetShapeDimension();
    // V1 is flattened basis eval matrix
    // int     evalsz = roots[0].size()*N;
    //cout<<"\n optima in pq sz = "<<roots.size()<<" "<<roots[0].size()<<"\n\n";
    //for(int ii = 0; ii < roots[0].size(); ii++)
    // {
    //    cout<<        roots[0][ii]<<" ";
    // }
    //cout<<"\n";

    // eval basis at roots
    //    cout<<"\n uhats in pq:\n";
    //for(int ii = 0; ii < uhats.size(); ii++)
    //{
    //    cout<<        uhats[ii]<<" ";
    //}
    //cout<<"\n";
    
    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        Array<OneD, NekDouble> tmparr(dim);
        for(int k = 0; k<dim; k++)
        {
            tmparr[k] = roots[k][ii];
        }
        for(int jj = 0; jj <N; jj++)
        {
            V1.push_back(E->PhysEvaluateBasis(tmparr, jj));
        }
    }
    // V2 = mat_mat_dot(V1,V1);
    // and
    // vector<double> Vsum = mat_sum_dim(V2,2);

    //    cout<<"\n V.*V=\n";
    for( int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &V1[i*N], 1, &wsp1[0], 1);

        Vsumsq.push_back(1.0/pow(Vmath::Vsum(N, &wsp1[0], 1),0.5));
    }

    /*    cout<<"\n cfun(opt)\n:";
    for(int ii = 0; ii<roots[0].size(); ii++)
        cout<<Vsumsq[ii]<<" ";
    cout<<"\n\n";
    */
    //vector<double> mv = mat_vec(V1,uhats);
    //cout<<"\n numerator:\n\n";
    for(int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &uhats[0], 1, &wsp1[0], 1);
        fvals.push_back( Vmath::Vsum(N, &wsp1[0], 1));
        //cout<<fvals[i]<<" ";

    }

    //cout<<"\n\n";
    //    cts = vec_vec_dot(Vsumsq, ret);
    Vmath::Vmul(roots[0].size(), &Vsumsq[0], 1, &fvals[0], 1, &fvals[0], 1);

    //    cout<<"\n pq returns:\n";
    cout<<"\n fvals:\n";
    for(int i = 0; i < roots[0].size(); i++)
    {
        cout<<" ("<<roots[0][i]<<" "<<//roots[1][i]<<")="<<
            fvals[i]<<" ";
    }
    cout<<"\n\n";

    int minidx = Vmath::Imin(fvals.size(), &fvals[0], 1);
    pqevalxast[0] = fvals[minidx];
    for(int k = 0; k < pqevalxast.size()-1; k++)
    {
        pqevalxast[k+1] = roots[k][minidx];
    }
    /*     cout<<"\n 1\n\n";
     cout<<"\n pq returns:\n\n";
     cout<<"pqeval = "<< pqevalxast[0] <<" xast = "<< pqevalxast[1]<<"\n\n";  */ 

}


void Do_optimize(Array<OneD, NekDouble> &uhats)
{

    int dim = E->GetShapeDimension();
    int numedges = 1;
    if(dim>1)
    {
        numedges = E->GetNtraces();
    }

    // uhats[0] =  0.331730709814333;
    // uhats[1] =   0.459076341659940;
    // uhats[2] =   0.363919276512675;
    // uhats[3] =  -0.056672051052144;
    // cout<<"\n in do_opt: uthas.size() = "<<uhats.size()<<"\n";
    double inf = numeric_limits<double>::infinity();
    //assert(size(constraints, 1) == N+2);
    int N1 = uhats.size();
    vector<Array<OneD,NekDouble> > d;
    d.push_back(uhats);
    int counter = 0;

    //    int NC = ck[1].size();          // number of constraints
    vector<double> tols;         // constraint specific tolerances

    int niter = 1e3;
    vector< vector<NekDouble> > optima;
    
    //    int NC = 1; //number of constraints, only positivity for now
    tols.push_back(1e-11);
    Array<OneD, NekDouble>  pqvalxast(dim+1), xastarr(dim), utemp, wsp1(N1);   
    Array<OneD, Array<OneD, NekDouble> > Pf(numedges);
    
   //    Array<OneD, Array<OneD, NekDouble> >;
    NekDouble pqval;//, minel;// minidx;
  
   while (counter <= niter)
    {
        
        pqval = inf;
        
        //cout<<"\n counter = "<<counter<<"\n\n";       
        utemp = d.back();
        //        cout<<"\n at counter "<<counter<<" init uhats = ";
        //for(int kk = 0; kk < N1; kk++)
        //    cout<<utemp[kk]<<" ";
        //cout<<"\n";
        //pq = @(xx) cfun(xx) .* (constraints(1,jj).*Vc(xx)*uhats);          
        project_edges(utemp, Pf, 1);
        /*        cout<<"\n Pf:\n\n";
        for(int kk = 0; kk <Pf.size(); kk++)
        {
            for(int ll = 0; ll < Pf[0].size(); ll++)
            {
                cout<<Pf[kk][ll]<<" ";
            }
            cout<<"\n";
            }*/
        
        //cout<<"\n\n\n\n";
        //exit(0);
        optima = (call_find_roots(utemp, 0, Pf));
        
        /*        cout<<"\n optima in do_opt: "<<optima.size()<<"\n";
        for(int pp = 0; pp < optima.size(); pp++)
        {
            for(int jj = 0; jj < optima[0].size(); jj++)
            {
                cout<<optima[pp][jj]<<" ";
            }
            cout<<"\n";
        }
        cout<<"\n";*/
        //exit(0);
        /*        cout<<"\n uhatpqd: ";
        for(int ii = 0; ii<Pf.size(); ii++)
            cout<<Pf[ii]<<" ";
        cout<<"\n";
        */
        pq(utemp, optima, pqvalxast, wsp1);
           
        //        cout<<"\n pq returns:\n\n";
        //cout<<"pqval = "<< pqvalxast[0] <<" xast = "<< pqvalxast[1]<<"pqval = "<<pqval<<"\n\n";   

        if (pqvalxast[0] < pqval)
        {
            for(int k = 0; k  < dim; k++)
            {
                xastarr[k] = pqvalxast[k+1];//optima[0][minidx];
            }
            pqval = pqvalxast[0];
            //jval = jj; //<- use for multiple constraints
        }
        
        //}
        
        cout<<"\n at counter="<<counter<<" min val="<<pqval<<" xast ="<<xastarr[0]<<" "<<//xastarr[1]<<
            "\n\n";
        // If minimum is non-negative, we're done
        if (pqval >= -tols.at(0))
        {
            break;
        }
        
        vector<NekDouble> Vastsq;
        vector<NekDouble> Vast;
        
        NekDouble vastsqsum;
        
        //Vast= poly_eval(xastv,N1,ck[1][jval]);
        //Vastsq = mat_mat_dot(Vast,Vast);
        //cout<<"\n N1 = "<<N1<<"\n";
        
        for( int ii = 0; ii < N1; ii++)
        {
            Vast.push_back(E->PhysEvaluateBasis(xastarr, ii));
            Vastsq.push_back(Vast[ii]*Vast[ii]);
        
        }
        //cout<<"\n heredasdas N1="<<N1<<"\n\n";     
        
        //Vmath::Vmul(N1, &Vast[0], 1, &Vast[0], 1, &Vastsq[0], 1);
        vastsqsum = Vmath::Vsum(N1, &Vastsq[0], 1);

        Array<OneD, NekDouble>  qast(N1);

        for(int i = 0; i<N1; i++)
        {
            qast[i] = ((1/sqrt(vastsqsum))*(Vast[i]));
        }
        Vmath::Smul(N1, pqval, &qast[0], 1, &qast[0], 1);
        
        Vmath::Vsub(utemp.size(), &utemp[0], 1, &qast[0], 1, &qast[0], 1);
        d.push_back(qast);
        /*
        cout<<"\n at counter = "<<counter<<" final uhats:;\n";
        for(int ii = 0; ii < qast.size(); ii++)
            cout<<qast[ii]<<" ";
        cout<<"\n";
        */
        counter = counter + 1;
    
    
    }
    cout<<"sphere_rotation took "<<counter<<"  iterations\n ";
    uhats = d.back();       
    cout<<"\n do_opt returning uhats\n";
    for(int ii = 0; ii < uhats.size(); ii++)
        cout<<uhats[ii]<<" ";
    cout<<"\n";
}


// Array<OneD, Array<OneD,NekDouble> > uhatpqd(
//                                         Array<OneD, NekDouble > c, 
//                                         Array<OneD, NekDouble > qw, 
//                                         Array<OneD, NekDouble > V,
//                                         Array<OneD, NekDouble > Vd,
//                                         Array<OneD, NekDouble > V3
//                                         )
// {

//     int dim = E->GetShapeDimension();

//     Array<OneD, Array<OneD,NekDouble> > ret(dim); 
//     Array<OneD, NekDouble> temp(qw.size()), pqeval(qw.size());
//     //pqeval = -(sum(V(:,:,1+d).*V(:,:,2+d), 2)).*(V(:,:,1+d)*c) + (sum(V(:,:,1+d).*V(:,:,1+d), 2)).*(V(:,:,2+d)*c);
//     cout<<"\n c ="<<c.size()<<"\n";
//     cout<<"\n Vd = "<<Vd.size()<<"\n";       
//     for(int ii = 0; ii<Vd.size(); ii++)
//         cout<<Vd[ii]<<" ";
//     cout<<"\n";

//     //Vd*c
//     cout<<"\n Vd*c=\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &Vd[i], qw.size(), &c[0], 1, &ret[0], 1);
//         temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
//         cout<<" "<<temp[i];
//     }

//     //temp * sum(V.*V,2)
//     cout<<"\n prev*sum(V.*V,2:\n";
//     //    cout<<"\n pqeval:\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &V[i], qw.size(), &ret[0], 1);
//         //cout<<" "<< Vmath::Vsum(c.size(), &ret[0], 1);
    
//         pqeval[i] = temp[i] * Vmath::Vsum(c.size(), &ret[0], 1);
//         cout<<pqeval[i]<<" ";
    
//     }

//     //V*c
//     //cout<<"\nVc\n\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &c[0], 1, &ret[0], 1);
//         temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
//         //   cout<<temp[i]<<" ";
//     }

//     //temp*sum(V.*Vd,2)
//         cout<<"\n temp*sum(V.*Vd,2):\n";
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(c.size(), &V[i], qw.size(), &Vd[i], qw.size(), &ret[0], 1);
//         NekDouble tt= (Vmath::Vsum(c.size(), &ret[0], 1));
//         pqeval[i] =  pqeval[i] - temp[i] * tt;
//         cout<<tt<<" ";
//     }
//         cout<<"\n\n";
    
//     //pqeval = vec_vec_dot(pqeval, qw);

//     /*cout<<"\n pqeval ="<<pqeval.size()<<"\n";
//     for(int ii = 0; ii<pqeval.size(); ii++)
//         cout<<pqeval[ii]<<" ";
//     cout<<"\n qw ="<<qw.size()<<"\n";
//     for(int ii = 0; ii<qw.size(); ii++)
//         cout<<qw[ii]<<" ";
//     */
//     Vmath::Vmul(qw.size(), &pqeval[0], 1, &qw[0], 1, &pqeval[0], 1);
//     Array<OneD, NekDouble> rettemp(qw.size()), rettemp2(qw.size());
//     //    ret = mat_vec(mat_T(V3),ret);
//     cout<<"\n uhatpqd: qw.size()="<<qw.size()<< " "<<pqeval.size();
//     for(int i = 0; i < qw.size(); i++)
//     {
//         Vmath::Vmul(qw.size(), &pqeval[0], 1, &V3[0]+i*qw.size(), 1, &rettemp[0], 1 );
//         rettemp2[i] = Vmath::Vsum(qw.size(), &rettemp[0], 1);
//          cout<<rettemp2[i]<<" ";
//     }
//     //cout<<"\n\n";

//     return rettemp2;
// }



NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff)
{
    map<ShapeType, function<int(int, const vector<int> &)>> shapeConstraint2;
    shapeConstraint2[ePoint] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eSegment] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eTriangle] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[eQuadrilateral] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eTetrahedron] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePyramid] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePrism] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eHexahedron] =
            [](int,   const vector<int> &order) { return order[1]; };

    map<ShapeType, function<int(int, int, const vector<int> &order)>>
            shapeConstraint3;
    shapeConstraint3[ePoint] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eSegment] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTriangle] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eQuadrilateral] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTetrahedron] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePyramid] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePrism] =
            [](int k, int,   const vector<int> &order) { return order[2] - k; };
    shapeConstraint3[eHexahedron] =
            [](int,   int,   const vector<int> &order) { return order[2]; };

    NekDouble sol = 0.0;
    if (!diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += sin(k * M_PI * x) + cos(k * M_PI * x);
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eSegment)
        {
            sol += 0.25 * sin(M_PI * x) + 0.25 * cos(M_PI * x);
        }
        else if (btype[0] == eFourier && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1] / 2; ++l)
                    {
                        sol += sin(k * M_PI * x) * sin(l * M_PI * y) +
                               sin(k * M_PI * x) * cos(l * M_PI * y) +
                               cos(k * M_PI * x) * sin(l * M_PI * y) +
                               cos(k * M_PI * x) * cos(l * M_PI * y);
                    }
                }
            }
            else if (btype[1] == eFourierSingleMode)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    sol += sin(k * M_PI * x) * sin(M_PI * y) +
                           sin(k * M_PI * x) * cos(M_PI * y) +
                           cos(k * M_PI * x) * sin(M_PI * y) +
                           cos(k * M_PI * x) * cos(M_PI * y);
                }
            }
            else
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1]; ++l)
                    {
                        sol += sin(k * M_PI * x) * pow_loc(y, l) +
                               cos(k * M_PI * x) * pow_loc(y, l) ;
                    }
                }
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(M_PI * x) * sin(l * M_PI * y) +
                           sin(M_PI * x) * cos(l * M_PI * y) +
                           cos(M_PI * x) * sin(l * M_PI * y) +
                           cos(M_PI * x) * cos(l * M_PI * y);
                }

            }
            else if (btype[1] == eFourierSingleMode)
            {
                sol += sin(M_PI * x) * sin(M_PI * y) +
                       sin(M_PI * x) * cos(M_PI * y) +
                       cos(M_PI * x) * sin(M_PI * y) +
                       cos(M_PI * x) * cos(M_PI * y);
            }
            else
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += sin(M_PI * x) * pow_loc(y, l) +
                           cos(M_PI * x) * pow_loc(y, l);
                }
            }
        }
        else if (btype[1] == eFourier && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(l * M_PI * y) * pow_loc(x, k) +
                           cos(l * M_PI * y) * pow_loc(x, k);
                }
            }
        }
        else if (btype[1] == eFourierSingleMode && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                sol += sin(M_PI * y) * pow_loc(x, k) +
                       cos(M_PI * y) * pow_loc(x, k);
            }
        }
        else
        {
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        sol += pow_loc(x, k) * pow_loc(y, l) * pow_loc(z, m);
                    }
                }
            }
        }
    }
    else if (diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += k * M_PI * (cos(k * M_PI * z) - sin(k * M_PI * z));
            }
        }
        else if (btype[0] != eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += k * pow_loc(x, k - 1) * sin(M_PI * l * y)
                           + M_PI * l * pow_loc(x, k) * cos(M_PI * l * y) +
                           +k * pow_loc(x, k - 1) * cos(M_PI * l * y)
                           - M_PI * l * pow_loc(x, k) * sin(M_PI * l * y);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] != eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1) +
                           -M_PI * k * sin(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * sin(M_PI * k * x) * cos(M_PI * l * y)
                           + M_PI * k * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * sin(M_PI * k * x) * sin(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * cos(M_PI * k * x) * sin(M_PI * l * y);
                }
            }
        }
        else
        {
            NekDouble a;
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        a = k * pow_loc(x, k - 1) * pow_loc(y, l) *
                            pow_loc(z, m);
                        sol += a;
                        a = l * pow_loc(x, k) * pow_loc(y, l - 1) *
                            pow_loc(z, m);
                        sol += a;
                        a = m * pow_loc(x, k) * pow_loc(y, l) *
                            pow_loc(z, m - 1);
                        sol += a;
                    }
                }
            }
        }
    }

    return sol;
}
