///////////////////////////////////////////////////////////////////////////////
//
// File: NodalDemo.cpp
//
// For more information, please see: http://www.nektar.info
//
// The MIT License
//
// Copyright (c) 2006 Division of Applied Mathematics, Brown University (USA),
// Department of Aeronautics, Imperial College London (UK), and Scientific
// Computing and Imaging Institute, University of Utah (USA).
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Description: Demo for testing functionality of StdProject
//
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <LibUtilities/Polylib/Polylib.h>
#include "StdDemoSupport.hpp"
namespace po = boost::program_options;

NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff);

//Modification to deal with exact solution for diff. Return 1 if integer < 0.
static double pow_loc(const double val, const int i)
{
    return (i < 0) ? 1.0 : pow(val, i);
}

Array<OneD, NekDouble> V;
Array<OneD, NekDouble> Vall;
Array<OneD, NekDouble> V3;
Array<OneD, NekDouble> Vd;
Array<OneD, NekDouble> Vxm1;
Array<OneD, NekDouble> Vdyxm1;
Array<OneD, NekDouble> Vx1 ;
Array<OneD, NekDouble> Vdyx1;
Array<OneD, NekDouble> Vdxy1;
Array<OneD, NekDouble> Vy1;
Array<OneD, NekDouble> Vym1;
Array<OneD, NekDouble> Vdxym1;

void  pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector<  NekDouble> >roots,
                          Array<OneD,NekDouble> &pqevalxast,
                          Array<OneD,NekDouble> &wsp1
                          );


//declare Do_optimize
void Do_optimize(Array<OneD, NekDouble> &uhats);

//declare find_roots
vector<vector<  NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d = 0, int dimension = 1);

// declare caller routine to find_roots
vector<vector<  NekDouble> > call_find_roots(Array<OneD, NekDouble> &uhatsall, int d = 0, Array< OneD, Array<OneD, NekDouble> >&uhatsedges =NullNekDoubleArrayofArray );


//declare Opt_needed
int Opt_needed(Array<OneD, NekDouble> uhats);

// find eigenvalue
vector< NekDouble> FindEigenval(vector< NekDouble > &CM,
                  int N);
                  //     Array<OneD, NekDouble> &EIG_I);//      double*EIG_R, 
//double*EIG_I);

Array<OneD, NekDouble >  uhatpqd(
                                        Array<OneD, NekDouble > c, 
                                        Array<OneD, NekDouble > qw, 
                                        Array<OneD, NekDouble > V,
                                        Array<OneD, NekDouble > Vd,
                                        Array<OneD, NekDouble > V3
                                                 );


//declare monomial_connection
Array<OneD, Array<OneD, NekDouble> >monomial_connection(int N);

// for 2D elements to get uhats at edges
// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,Array<OneD, Array<OneD, NekDouble> >&ret , int d = 0);


// Companion matrix
Array<OneD, Array<OneD, NekDouble> > C;
StdExpansion *E;
StdExpansion *E3;
double *a;
double *b;
Array<OneD, NekDouble> qZin; //inner point grid for 2D rootfinding
Array<OneD, NekDouble> qx;
Array<OneD, NekDouble> qw;
Array<OneD, NekDouble> qwmore;
Array<OneD, NekDouble> qxmore;

int main(int argc, char *argv[])
{
    DemoSupport demo;
    demo.GetOptions().add_options()("optm,z", "positivity preserving optimizer");
    demo.ParseArguments(argc, argv);
    
    po::variables_map vm = demo.GetVariableMap();
    // string shape = vm["shape"].as<string>();
    
    // if(shape == "segment")
    // {
    //     dimension = 1;
    // }
/*
    po::parsed_options parsed_options = po::command_line_parser(argc, argv)
        .options(demo.GetOptions())
        .run();
    std::vector<std::vector<std::string>> lists;
    int dimension = 0;
    for (const po::option& o : parsed_options.options) {
            if (o.string_key == "order")
            {   lists.push_back(o.value);
                dimension = o.value.size();
            } 
            
        }  

    vector<PointsKey> &pkey = demo.GetPointsKey();        
    vector<BasisKey> &bkey = demo.GetBasisKey();
    cout<<"\n dimension = "<<dimension;

    for(int k = 0; k < dimension; k++)
    {
        int coeffsz = std::stoi(lists[0][k]);
        cout<<"coeffsz = "        <<coeffsz<<"\n\n";    
        pkey[k] =  LibUtilities::PointsKey (3*coeffsz, pkey[k].GetPointsType());
        bkey[k] = LibUtilities::BasisKey(bkey[k].GetBasisType(), (coeffsz),  pkey[k]);
    }*/

    //only for 1D
       
    E = demo.CreateStdExpansion();
    if (E == nullptr)
    {
        return 1;
    }
    int dimension = E->GetShapeDimension();
    
    std::vector<int> order;
    std::vector<BasisType> btype(3, eNoBasisType);
    LibUtilities::ShapeType stype = E->DetShapeType();
    for (int i = 0; i < dimension; ++i)
    {
        btype[i] = E->GetBasisType(i);
        order.push_back(E->GetBasisNumModes(i));
    }

    if(dimension > 1)
    {
        //prep for gradient descent
        // 5extra points in the interior
        LibUtilities::PointsType quadPTCheb = LibUtilities::eGaussGaussChebyshev;

        const LibUtilities::PointsKey quadPointsKeyin(order[0]+5, quadPTCheb);  
        qZin = (LibUtilities::PointsManager()[quadPointsKeyin])->GetZ();
    }


    //only for seg
    //cout<<"\n 3*order[0]-1="<<3*order[0]-1<<"\n";
    C = monomial_connection(3*(order[0]+1)); //+1 for luck
    // print C here:
    /*cout<<"\n C:\n";
    for( int ii = 0; ii <3*( order[0]+1); ii++)
    {
        for(int jj = 0; jj< 3*(order[0]+1); jj++)
        {
            cout<<C[ii][jj]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */    
    const auto totPoints = (unsigned) E->GetTotPoints();
    //cout<<"\n herererer totpoints = "<<totPoints<<"\n\n";

    Array<OneD, NekDouble> x = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> y = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> z = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dx = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dy = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> dz = Array<OneD, NekDouble>(totPoints);
    Array<OneD, NekDouble> sol = Array<OneD, NekDouble>(totPoints);


    switch (dimension)
    {
        case 1:
        {
            E->GetCoords(x);
            break;
        }

        case 2:
        {
            E->GetCoords(x, y);
            break;
        }

        case 3:
        {
            E->GetCoords(x, y, z);
            break;
        }
        default:
            break;
    }

    //get solution array
    for (int i = 0; i < totPoints; ++i)
    {
        //  sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, false)-1.0;
        if(dimension ==2)
        {
        if(x[i]<=-0.2 && y[i] <=-0.2)
            sol[i] = 0;
        else sol[i] = 0.5*pow(x[i]*y[i],2);
        }
        else{
            if(x[i]<=-0.2 )
            sol[i] = 0;
        else sol[i] = 0.5*pow(x[i],2);
        }//cout<<"\nx["<<i<<"]="<<x[i];
    }

    Array<OneD, NekDouble> phys(totPoints);
    Array<OneD, NekDouble> coeffs((unsigned) E->GetNcoeffs());

    //print sol:
       cout<<"\n sol:\n";
    for(int ii = 0; ii < sol.size(); ii++)
        cout<< sol[ii]<<" ";
    cout<<"\n";
    
    //Project onto expansion
    E->FwdTrans(sol, coeffs);

    //Backward transform solution to get projected values
    E->BwdTrans(coeffs, phys);
    
    cout<<"\n phys:\n";
    for(int ii = 0; ii < phys.size(); ii++)
        cout<< phys[ii]<<" ";
    cout<<"\n\n";
    

    // check for -ve values and apply opt if necessary
    if (vm.count("optm"))
    {
        int dimension = E->GetShapeDimension(); 
        vector<string> &ptypes = demo.GetPointsType();
        LibUtilities::PointsType pointsTypeCheb =
            LibUtilities::eGaussGaussLegendre;
        
        vector<PointsKey> &pkey = demo.GetPointsKey();
        vector<BasisKey> &bkey = demo.GetBasisKey();
        for(int k = 0; k < dimension; k++)
        {
            ptypes[k] = "GaussGaussLegendre";
            
            pkey[k] =  LibUtilities::PointsKey (3*(coeffs.size()), pointsTypeCheb);
            bkey[k] = LibUtilities::BasisKey(LibUtilities::eOrtho_A, 3*(coeffs.size()),  pkey[k]);
        }

        E3 = demo.CreateStdExpansion();
        if (E3 == nullptr)
        {
            return 1;
        }
        //  Array<OneD, Array<OneD, NekDouble> >qxmorearr = demo.GetCoords(E3);//->GetZ();
        Array<OneD, Array<OneD, NekDouble> >qxmorearr(dimension), qxarr(dimension);
        qxmore = E3->GetBasis(0)->GetZ();//qxmorearr[0];
        qwmore = E3->GetBasis(0)->GetW();
        qw = E->GetBasis(0)->GetW();
        qx = E->GetBasis(0)->GetZ();
        qxmorearr[0] = qxmore;
        qxarr[0] = qx;
        cout<<"\n coeffs = ";
        for(int ii = 0; ii < coeffs.size(); ii++)
            cout<<coeffs[ii]<<" ";
        cout<<"\n\n";
        
        //int sz = qxmore.size()*(N1);
        //        int sz3 = qxmore.size()*(3*(N1));

        Vd = Array<OneD, NekDouble>(qxmore.size()*coeffs.size());
        V = Array<OneD, NekDouble>(qxmore.size()*coeffs.size());
        V3 = Array<OneD, NekDouble>(qxmore.size()*coeffs.size()*3);
        E->PhysEvalBasisGrad(qxmorearr,V, Vd, NullNekDouble1DArray,  NullNekDouble1DArray);

        //        V  = E->GetBasis(0)->GetBdata();
        //        Vd = E->GetBasis(0)->GetDbdata();
        //        V3 = E3->GetBasis(0)->GetBdata(); 
        //        int sz = V.size();
        // cout<<"\n sz ="<< sz<<" E->GetTotPoints()="<<E->GetTotPoints()<<" *E->GetNcoeffs()="<<E->GetNcoeffs()<<"V3.size="<<V3.size()<<"\n\n";
E3->PhysEvalBasisGrad(qxmorearr, V3,  NullNekDouble1DArray, NullNekDouble1DArray,  NullNekDouble1DArray);
cout<<"\n Vd:\n";
/*for(int kk = 0; kk < Vd.size(); kk++)
            {
                cout<<" "<<Vd[kk];
            }
*/

        //E3->PhysEvalBasisGrad(qxmorearr, V3,  NullNekDouble1DArray, NullNekDouble1DArray,  NullNekDouble1DArray);

        if(dimension == 2 && E->GetNtraces() == 4)
        {
            // populate edge root finding matrices for quadrilateral
            Array<OneD, Array<OneD, NekDouble> > coords = demo.GetCoords(E);
            Vall = Array<OneD, NekDouble> (coords[0].size()*coeffs.size());
            E->PhysEvalBasisGrad(coords, Vall, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
            /*Array<OneD, NekDouble> tmpphys(coords[0].size());
            cout<<"\n tmpphys:\n";
            for(int kk = 0; kk < coords[0].size(); kk++)
            {
                Array<OneD, NekDouble> hold1(coeffs.size());
                Vmath::Vmul(coeffs.size(), &Vall[kk], coords[0].size(), &coeffs[0], 1, &hold1[0], 1 );
                tmpphys[kk] = Vmath::Vsum(coeffs.size(), hold1, 1);
                cout<<" "<<tmpphys[kk];
            }
            cout<<"\n\n";
            exit(0);  
            */
            /*            cout<<"\n phys:\n";
            for(int ii = 0; ii < phys.size(); ii++)
            cout<< phys[ii]<<" ";
            cout<<"\n\n";
            */
            
            //cout<<"\n coeffs.size(0="<<coeffs.size();
            int totsz = E->GetTotPoints()*E->GetNcoeffs();
            Vxm1 = Array<OneD, NekDouble>(totsz);//qx.size());//sz);
            Vdyxm1 = Array<OneD, NekDouble>(totsz);//sz);
            Vx1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdyx1 = Array<OneD, NekDouble>(totsz);//sz);
            Vdxy1 = Array<OneD, NekDouble>(totsz);//sz);
            Vy1 = Array<OneD, NekDouble>(totsz);//sz);
            Vym1  = Array<OneD, NekDouble>(totsz);//sz);
            Vdxym1  = Array<OneD, NekDouble>(totsz);//sz);

            qxarr[1] = Array<OneD, NekDouble>(qx.size(), -1.0);
            
            E->PhysEvalBasisGrad(qxarr,  Vym1, Vdxym1,  NullNekDouble1DArray , NullNekDouble1DArray);
            //cout<<"\n qxarr sz = "<<qxarr[0].size();
            /*for (int p = 0; p < qx.size(); p++)
            {
                Array<OneD, NekDouble> tmp(2);
                tmp[0] = qxarr[0][p];
                tmp[1] = -1;
                Vym1[p] = E->PhysEvaluate(tmp, E->m_physevalall[0]);
                tmp[1] = 1;
                Vy1[p] = E->PhysEvaluate(tmp, E->m_physevalall[0]);
                tmp[1] = tmp[0];
                tmp[0] = -1;
                Vxm1[p] = E->PhysEvaluate(tmp, E->m_physevalall[0]);
                tmp[0] = 1;
                Vx1[p] = E->PhysEvaluate(tmp, E->m_physevalall[0]);
            }*/

            //            E->PhysEvalGrad(qxarr, E->m_physevalall[0], Vdxym1, NullNekDouble1DArray, NullNekDouble1DArray);
            
            qxarr[1] = Array<OneD, NekDouble>(qx.size(), 1.0);             E->PhysEvalBasisGrad(qxarr, Vy1, Vdxy1, NullNekDouble1DArray, NullNekDouble1DArray);

            //            E->PhysEvalBasisGrad(qxarr,  Vy1, Vdxy1,  NullNekDouble1DArray , NullNekDouble1DArray);
            qxarr[1] = qxarr[0];
            qxarr[0] = Array<OneD, NekDouble>(qx.size(), -1.0);
            E->PhysEvalBasisGrad(qxarr,Vxm1, NullNekDouble1DArray, Vdyxm1, NullNekDouble1DArray);

            //            E->PhysEvalBasisGrad(qxarr,  Vxm1,   NullNekDouble1DArray , Vdyxm1, NullNekDouble1DArray);        
            qxarr[0] = Array<OneD, NekDouble>(qx.size(), 1.0); 
            E->PhysEvalBasisGrad(qxarr, Vx1, NullNekDouble1DArray, Vdyx1, NullNekDouble1DArray);
             cout<<"\n here?\n\n";  

            //            coords[0] = Array<OneD, NekDouble>(coords[0].size(), 1.0);
   
            //E->PhysEvalBasisGrad(qxarr,  Vx1,   NullNekDouble1DArray , Vdyx1, NullNekDouble1DArray);        

        } 
        coeffs[0] =  0.331730709814333;
     coeffs[1] =   0.459076341659940;
     coeffs[2] =   0.363919276512675;
     coeffs[3] =  -0.056672051052144;
    
        if(Opt_needed(coeffs))
        {
            cout<<"\n need optimization\n\n";
            
            Do_optimize(coeffs);
            
            cout<<"\n doopt done\n verifying...\n";//exit(0);
            cout<<"\n do_opt returning uhats\n";
            for(int ii = 0; ii < coeffs.size(); ii++)
                cout<<coeffs[ii]<<" ";
            cout<<"\n";
            if(Opt_needed(coeffs))
            {
                cout<<"\n fail\n\n";
                exit(0);
            }
            else
            {
                cout<<"\n pass\n\n";exit(0);
            }
        }
        else{
            cout<<"\n optimizer no need\n\n";
        }
        //Backward transform solution to get projected values
        E->BwdTrans(coeffs, phys);

    }

    

    /*if (vm.count("diff"))
    {
        for (int i = 0; i < totPoints; ++i)
        {
            sol[i] = Shape_sol(x[i], y[i], z[i], order, btype, stype, true);
        }
    }*/

    //Calculate L_inf & L_2 error
    cout << "L infinity error: \t" << E->Linf(phys, sol) << endl;
    if (stype != ePoint)
    {
        cout << "L 2 error: \t \t \t" << E->L2(phys, sol) << endl;
    }

    if (!vm.count("diff") && stype != ePoint)
    {
        //Evaluate solution at x = y = 0 and print error
        Array<OneD, NekDouble> t = Array<OneD, NekDouble>(3);
        t[0] = -0.5;
        t[1] = -0.25;
        t[2] = -0.3;
        sol[0] = Shape_sol(t[0], t[1], t[2], order, btype, stype, false);

        NekDouble nsol = E->PhysEvaluate(t, phys);

        cout << "Error at x = (";
        for (int i = 0; i < dimension; ++i)
        {
            cout << t[i] << ", ";
        }
        cout << "\b\b): " << nsol - sol[0] << endl;
    }

    // Calculate integral of known function to test different quadrature
    // distributions on each element.
    for (int i = 0; i < totPoints; ++i)
    {
        sol[i] = dimension == 1 ? exp(x[i]) : dimension == 2 ?
            exp(x[i]) * sin(y[i]) : exp(x[i] + y[i] + z[i]);
    }

    NekDouble exact = 0.0;
    switch(stype)
    {
        case eSegment:
            exact = M_E - 1.0 / M_E;
            break;
        case eTriangle:
            exact = -0.5 * (sin(1.0) + cos(1.0) + M_E * M_E *
                            (sin(1.0) - cos(1.0))) / M_E;
            break;
        case eQuadrilateral:
            exact = 2.0 * (M_E - 1.0 / M_E) * sin(1.0);
            break;
        case eTetrahedron:
            exact = 1.0 / M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePrism:
            exact = M_E - 1.0 / M_E / M_E / M_E;
            break;
        case ePyramid:
            exact = - 1.0 / M_E / M_E / M_E - 4.0 / M_E + M_E;
            break;
        case eHexahedron:
            exact = pow((M_E * M_E - 1.0) / M_E, 3.0);
            break;
        default:
            ASSERTL0(false, "Exact solution not known.");
            break;
    }
    std::cout << "Integral error: " << fabs(exact - E->Integral(sol))
              << std::endl;

    return 0;
}

// when d = 1, its the uhatpqd case from do_optimize
void project_edges( Array<OneD, NekDouble>&uhats,    Array<OneD, Array<OneD, NekDouble> >&ret , int d)
{
    int numedges = ret.size();
        
    // assert d = 0 or 1
    if(d == 1)
    {
        //to-do assert that numedges = 3 or 4
        if(numedges == 4) //quadrilateral
        {

            // uhatpqd stuff
            // bot edge
            //            ret[0] = Array<OneD, NekDouble>();
            //DoProjectpq( ret[0], uhats, Vxm1, Vdyxm1);
            
        }
        else //triangle
        {
            cout<<"\n coming soon...\n";
        }
    }
    else
    {
        //normal projection of uhats
        if(numedges == 4) //quadrilateral
        {
            cout<<"\n all uhats:\n";
            for(int kk = 0 ; kk < uhats.size(); kk++)
            {
                cout<<uhats[kk]<<" ";
            }
            Array<OneD, NekDouble >qwall(qw.size()*qw.size());
            int ctr = 0;
            for(int kk = 0 ; kk < qw.size(); kk++)
            {
                 for(int ii = 0 ; ii < qw.size(); ii++)
                 {
                     qwall[ctr++] = qw[ii]*qw[kk];
                 }
            }
           
           
            int modes = E->GetNcoeffs();
            int totpts = E->GetTotPoints();
            cout<<"\n modes = "<<modes<<"\n";
            // bot edge = 0, y = -1
            // right edge = 1, x = 1
            // top edge = 2, y = 1
            // left edge = 3, x = -1
            ret[0] = Array<OneD, NekDouble>(modes);        
            ret[1] = Array<OneD, NekDouble>(modes);
            ret[2] = Array<OneD, NekDouble>(modes);
            ret[3] = Array<OneD, NekDouble>(modes);
            Array<OneD, NekDouble> vals(totpts);//Vym1.size());

            cout<<"\n Vym1 "<<": sz = "<<Vym1.size()<<"\n";;
            for(int p = 0; p < Vym1.size(); p++)
                cout<<" "<<Vym1[p];
            cout<<"\n";
            cout<<"\n vym1 sz = "<<Vym1.size()<<" qwLL sz = "<<qwall.size()<<"uhats.size()="<<uhats.size()<<"totpts = "<<totpts<<"\n";
            //V*vals*qwmore
 
            //  
            //Vmath::Vmul(vals.size(), &qwall[0], 1, &vals[0], 1, &vals[0], 1); 
            cout<<"\n vals "<<":";
            for(int p = 0; p < vals.size(); p++)
                cout<<" "<<vals[p];
            cout<<"\n bot edge uhats:\n";
            
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(totpts, &Vym1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, qwall, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[0][k] = Vmath::Vsum(vals.size(), vals, 1);
                cout<<" "<<ret[0][k];
            }        
            cout<<"\n right edge uhats:\n";
            //Vmath::Vmul(modes, &Vx1[0], 1, &qw[0], 1, &vals[0], 1);
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(totpts, &Vx1[k], totpts, &uhats[0], 1, &vals[0], 1);
                Vmath::Vmul(totpts, qwall, 1, vals, 1, vals, 1);
                Vmath::Vmul(totpts, &Vall[k], 1, &vals[0], 1, &vals[0], 1);
                ret[1][k] = Vmath::Vsum(vals.size(), vals, 1);
                cout<<" "<<ret[1][k];
            }        

            cout<<"\n top edge uhats:\n";
            Vmath::Vmul(modes, &Vy1[0], 1, &qw[0], 1, &vals[0], 1);
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(modes, &V[k], modes, &vals[0], 1, &vals[0], 1);
                ret[2][k] = Vmath::Vsum(vals.size(), vals, 1);
                cout<<" "<<ret[2][k];
            }        
            cout<<"\n left edge uhats:\n";
            Vmath::Vmul(modes, &Vxm1[0], 1, &qw[0], 1, &vals[0], 1);
            for(int k = 0; k < modes; k++)
            {    
                Vmath::Vmul(modes, &V[k], modes, &vals[0], 1, &vals[0], 1);
                ret[3][k] = Vmath::Vsum(vals.size(), vals, 1);
                cout<<" "<<ret[3][k];
            }        
            exit(0);            
            
        }
        else//triangle
        {
            cout<<"\n coming soon...\n";
        }
    }
   
}


vector<vector<  NekDouble> > call_find_roots(Array<OneD,  NekDouble> &uhats , int d, Array<OneD, Array<OneD, NekDouble> >&uhatsedges)
{
    vector<vector<NekDouble> >row;
    int dimension = E->GetShapeDimension(); 
    vector<vector< NekDouble> > ret(dimension);

    if(dimension == 1)
    {
        //   Array<OneD, NekDouble> uhatd(V3.size());
        //DoProjectpq( uhatd, uhats, V, Vd);
        cout<<"\n 123\n\n";
        for(int kk = 0; kk < uhats.size(); kk++)
            cout<<uhats[kk]<<" ";
        ret = find_roots(uhats, d);
                cout<<"\n 123 roots seg:\n\n";
                for(int kk = 0; kk < ret[0].size(); kk++)
                    cout<<ret[0][kk]<<" ";                 
    }
    else if(dimension == 2)
    {

        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();


        // to-do: assert 2D elements allowed numedges = 3 or 4
        if( numedges == 4)
        {
            //if(d == 0)
            //{
            // for 2D, structure of roots vector:
            // row 0 vector = left edge
            // row 1 vector = right
            // row 2 vector = top
            // row 3 vector = bot
            // row 4 vector = {x1,x2} inner root
            
            
            
            for(int ii = 0; ii < numedges; ii++)
            {
                // size of tmp will be dim \times no. of roots
                vector<vector<NekDouble> > tmp = (find_roots(uhatsedges[ii], d, 1)) ;
                for(int p = 0; p < tmp[0].size(); p++)
                {
                    row[0].push_back(tmp[0][p]);
                    
                    row[1].push_back(tmp[1][p]);
                    
                }
                // only for 3D
                //ret[2].push_back(row[2]);
                
                
            }
            
            /*}
              else
              {
              
              row = find_roots(uhats[0], d, 0);
              ret.push_back(row);
              
              
              }*/
        }
        else
        {
            // triangle edge roots code
        }
        
        //find interior roots:
        //        ret.push_back(find_roots(uhats, 0, 1));
        vector<vector<NekDouble> > tmp = (find_roots(uhats, 0, dimension)) ;
        for(int p = 0; p < tmp[0].size(); p++)
        {
            row[0].push_back(tmp[0][p]);
            
            row[1].push_back(tmp[1][p]);
            
        }
    
    }
    else //3D
    {
        cout<<"\n coming soon....\n";
    }
    return ret;
}


// Called by call_find_roots depending on edges or interior region 
// rootfinding
// d=1 :: derivatives
// flag = 0, edges (1D rootfinding using confederate matrix)
// flag = 1, interior region rootfinding using gradient descent
vector<vector<NekDouble> > find_roots(Array<OneD, NekDouble> &uhats, int d, int flag)
{
    // to-do assert dimension is 1 2 or 3
    vector<vector< NekDouble> > ret;
                    cout<<"\n in findroots\n\n";
                for(int kk = 0; kk < uhats.size(); kk++)
                    cout<<uhats[kk]<<" ";
    //Confederate matrix approach
    if(flag == 1)
    {
        int N = uhats.size();
        vector<NekDouble> uhatsmon;
        cout<<"\n 123\n\n";        
        while(abs(uhats[N-1])<1e-8)
        {
            cout<<"N = "<<N<<"\n";
            N = N-1;
        } 
        vector<NekDouble> temp(N);
        
        // convert uhats to monomial, find roots of uhats or der of uhats
        // uhatsmon = C(1:numModes,1:numModes)'*uhats;
        
        //    cout<<"\n";

        for(int k = 0; k < N; k++)
        {
            for(int jj= 0 ; jj < N; jj++)
            {
                //cout<<C[jj][k]<<" ";
                temp[jj ] = C[jj][k];
            }
            //cout<<"\n";
            Vmath::Vmul(N, &temp[0], 1,  &uhats[0], 1, &temp[0], 1);
            uhatsmon.push_back(Vmath::Vsum(N, &temp[0], 1));
            //        cout<<"uhatsmon["<<k<<"]="<<uhatsmon[k]<<" \n";
        }
        //        cout<<"\n  d = "<<d<<"\n\n";;
        N = uhatsmon.size();
     

        // truncate trailing zeros
        
        // now size of uhatsmon = N;
        //    Array<OneD, NekDouble> uhatsdiff;
        vector<NekDouble> uhatsdiff;
        // if d == 1, 
        
        if(d == 1)
        {
            for(int k = 1; k < N; k++)
            {
                uhatsdiff.push_back(k*uhatsmon[k]);
            }
            N = N-1;
            
        }
        else //d == 0
        {
            uhatsdiff = uhatsmon;
            
        }
        //        cout<<"\n N new = "<<N;
        Vmath::Smul(N, 1.0/uhatsdiff[N-1], &uhatsdiff[0], 1, &uhatsdiff[0], 1);
        vector<NekDouble> EIG_R = FindEigenval(uhatsdiff, N);
        //cout<<"\n print done after eigenvals\n\n";
        
        
        ret.push_back( EIG_R );
    }
    else if(flag == 2)
    {
        // Gradient descent
        cout<<"\n gradient descent\n";
            // Assert that d = 0
        // Gradient descent
        //cout<<"\n gradient descent\n";
        int num = uhats.size(); 
        Array<OneD, NekDouble> temp(num);
        std::vector< std::vector<NekDouble> > R;
        Array< OneD, NekDouble> xast(2);
        //xast[0] = Array<OneD, NekDouble>(1); 
        //xast[1] = Array<OneD, NekDouble>(1);
        Array<OneD, NekDouble>Jg(2);
        Array<OneD, NekDouble> g(2);
        Array<OneD, NekDouble> evald0(num);
        Array<OneD, NekDouble> evald1(num);

        int ii,jj,kk, ctrn = 0;
        NekDouble epsl = 1.0, xs1 = 0, ys1 = 0;
        NekDouble x1, x2;
        int nmpt = E->GetTotPoints();
        for(ii = 0; ii < qZin.size(); ++ii)
        {
            for(jj = 0; jj < qZin.size(); ++jj)
            {
                x1 = qZin[ii], x2 = qZin[jj];
                //Array<OneD,NekDouble> x1a(1,x1);
                //Array<OneD,NekDouble> x2a(1,x2);
                xast[0] = x1;
                xast[1] = x2;
                //NekMatrix<NekDouble>      Vd1 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0, 0,0);
                
                //ptr->PhysEvalBasisGradFast(xast, NullNekDouble1DArray, evald0, evald1);      
                for(kk = 0; kk < num; kk++)
                {
                    evald0[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[1][nmpt*kk])); 
                    evald1[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[2][nmpt*kk])); 
                }
                Vmath::Vmul(num, &evald0[0], 1, &uhats[0], 1, &temp[0], 1);
                g[0] = Vmath::Vsum(num, temp, 1);                   
                //cout<<"\ng[0]="<<g[0]<<"\n\n";;
                Vmath::Vmul(num, &evald1[0], 1, &uhats[0], 1, &temp[0], 1);
                g[1] = Vmath::Vsum(num, temp, 1);                                      
                if(epsl > (abs(g[0]) + abs(g[1])))
                {
                    epsl = abs(g[0])+abs(g[1]);
                    xs1 = x1;
                    ys1 = x2;
                }
                ctrn++;
            }
        }
        
        int n = 0;
        x1 = xs1, x2 = ys1;
        //            cout<<"\n x1 = "<<x1<<" x2 = "<<x2<<"epsl = "<<epsl<<"\n\n";
        epsl = 1.0;
        
        Array<OneD,NekDouble> x1a(1), x2a(1);
        NekDouble stepsize = 1e-3, x1new = x1, x2new = x2, iter = 100;
        // loop for gradient descent 2D:
        while(epsl > 1e-11 && n < iter)
        {
            if(abs(x1new)<1e-12)
                x1new = 0.0;
            if(abs(x2new)<1e-12)
                x2new = 0.0;
            xast[0] = x1new;
            xast[1] = x2new;
            for(kk = 0; kk < num; kk++)
            {
                
                evald0[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[1][nmpt*kk])); 
                evald1[kk] = E->PhysEvaluate(xast, Array<OneD, NekDouble> (nmpt,E->m_physevalall[2][nmpt*kk])); 
                    
            }

            
            //print evald0:
            //cout<<"\n N = "<<N<<"\n";
            //cout<<"\n evald0:\n";
            //for(int ii = 0; ii<evald0.size(); ii++)
            //    cout<<" "<<evald1[ii];
            //cout<<"\n";
            //x1a[0] =x1new;//Array<OneD,NekDouble>(1,x1);
            //x2a[0] = x2new;//Array<OneD,NekDouble> x2a(1,x2);
            
            //                Vd1 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0,1 ,0);
            
            //print Vd1:
            //cout<<"\n Vd1:\n";
            //for(int ii = 0; ii<Vd1.GetColumns(); ii++)
            //    cout<<" "<<Vd1(0,ii);
            //cout<<"\n\n";
            
            
            Vmath::Vmul(num, &evald0[0], 1, &uhats[0], 1, &temp[0], 1);
            //Vmath::Vmul(num, &Vd1.GetPtr()[0], 1, &uhats[0], 1, &temp[0], 1);
            
            g[0] = Vmath::Vsum(num, temp, 1);
            //x1a[0] = x1;
            //x2a[0] = x2;
            //Vd2 = Polylib::PolyEval2(N, &x1a[0],&x2a[0],1, 1, 0.0, 0.0,0 ,1);
            
            Vmath::Vmul(num, &evald1[0], 1, &uhats[0], 1, &temp[0], 1);
            // Vmath::Vmul(num, &Vd2.GetPtr()[0], 1, &uhats[0], 1, &temp[0], 1);
            g[1] = Vmath::Vsum(num, temp, 1);
            
            epsl = abs(g[0])+abs(g[1]);
            x1new = x1 - stepsize*(g[0]);
            x2new = x2 - stepsize*(g[1]);
            //              cout<<"\n g[0] = "<<g[0]<<" g[1]="<<g[1]<<" epsl="<<epsl<<"x1 = "<<x1<<"x1new="<<x1new<<"n = "<<n<<"\n\n"; 
            if(x1new - x1 <1e-10 && x2new - x2<1e-10)
            {break;}
            
            if(abs(x1new)>1.0)
            {
                x1new = x1;
            }
            if(abs(x2new)>1.0)
            {
                x2new = x2;
            }
            
            n = n+1;
        }
        //cout<<"\n x1 = "<<x1<<"\t y1 = "<<x2<<"\n\n";
        //check
        if(abs(x1)<=1.0 && abs(x2)<=1.0)
            ret.push_back(std::vector<NekDouble>{x1,x2});   
        
    }
    else{
        
        cout<<"\n Dimension 3 coming soon...\n";
    }
    cout<<"\n ret from find_roots\n\n";
    return ret;    

}
    
    
Array<OneD, Array<OneD, NekDouble> > monomial_connection(int N)
{

    Array<OneD, Array<OneD, NekDouble> > R(N);
    a = new double[N];
    b = new double[N];    


    // Initialize a and b to zero
    for(int i = 0; i < N; i++)
    {
        a[i] = 0.0;
        b[i] = 0.0;
    }
    
    // [a,b] = jacobi_recurrence(maxN+1, 0, 0);
    
    Polylib::RecCoeff(N, a, b, 0.0, 0.0);
    //cout<<"\n a and b:\n";
    
    
    //     assert( (N >= numel(a)) && (N >= numel(b)) );

    //b = sqrt(b)
    transform(b, b+N, b, (double(*)(double)) sqrt);
    //b = 1./b
    Array<OneD, NekDouble> r(N, b);
    for(int i = 0; i<r.size(); i++)
    {
        r[i] = 1/r[i];
    }

   // local_leading_coeffs = cumprod(1./b);

    //r = cumprod(1./b) 
    partial_sum (r.begin(), r.end(), r.begin(), multiplies<double>());

    /*    cout<<"\n r:\n";
for(int i = 0; i<N; i++)
    {
        cout<<r[i]<<" ";   
        }*/

    //Build the connection matrix for this dimension and then distribute it accordingly

    for(int i = 0; i<N; i++)
    {
        Array<OneD, NekDouble> row(N);
        for(int j = 0; j<N; j++)
        {
            if( i == j)
            {
                row[i] = r[i];
            }

        }
            R[i] = row;

    }

    //print R:
    /*    cout<<"\n R=\n";
    for(int i = 0; i<N; i++)
    {
        for(int j = 0; j<N; j++)
        {
            cout<<R[i][j]<<" ";
        }
        cout<<"\n";
    }
    cout<<"\n";
    */
    for(int i = 1; i<N; i++)
    {
        //"side" conditions (i.e. those w/o left/right boundary points)
        if(i<2)
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0]);
        }
        else
        {
            R[i][0] = (1/b[i])*(-a[i-1]*R[i-1][0] - b[i-1]*R[i-2][0]);
            
            //All the rest are `vectorizable'
            for(int j = 1; j<i-1; j++)
            {
                R[i][j] = R[i-1][j-1] - a[i-1]*R[i-1][j] - b[i-1]*R[i-2][j];
                R[i][j] = R[i][j]/b[i];
            }
            
        }
    }
    /*  Array<OneD, Array<OneD, NekDouble> > Rtrans(R);
    for(int i = 0; i < R.size(); i++)
    {
        for(int j = 0; j < R[0].size(); j++)
        {
            Rtrans[i][j] = R[j][i];
        }
    } */

    return R;

}

vector< NekDouble> FindEigenval( vector<NekDouble> &uhatsdiff,
                   int N) 
{    
    boost::ignore_unused(N);
    int sizemat = uhatsdiff.size();
    Array<OneD, NekDouble> CMdiff(pow(sizemat-1,2),0.0);

//cout<<"\n cmdiff size = "<<CMdiff.size()<<"\n\n";
// Form companion matrix for maxima/minima
// CMdiff = eye(length(uhatsdiff)-2);
// and
    // CMdiff = [CMdiff -uhatsdiff(2:end-1)];
    // and
    // CMdiff = [[zeros(1,length(uhatsdiff)-2) -uhatsdiff(1)]; CMdiff];

/*for(int k = 0; k <sizemat; k++)
    {
        cout<<uhatsdiff[k]<<" ";
    }
cout<<"\n\n";*/
    for(int k = 1; k < sizemat-1; k++)
    {
        
        CMdiff[(k)*(sizemat-1) +k-1] = 1.0;
        CMdiff[(k+1)*(sizemat-1)-1 ] = -uhatsdiff[k];
    }    

    
    //CMdiff[0] = temp1;
    //temp1[N-2] = -uhatsdiff[0];
    //Vmath::Vcopy(N-1, &temp1[0], 1, &CMdiff[0][0], 1);
    //    CMdiff[0][uhatsdiff.size()-2] = -uhatsdiff[0];
    CMdiff[sizemat-2] = -uhatsdiff[0]; 

    const int sz = sizemat-1;//pow(CMdiff.size(),0.5);
    Array<OneD, NekDouble> Mat(sz*sz,0.0);
    const int  lwork = 3*(sz);

    Array<OneD, NekDouble> work1(lwork), EIG_temp(sz), EIG_I(sz);
    //    NekDouble *work1[lwork];
    //NekDouble *EIG_temp[sz];
    //NekDouble *EIG_I[sz];

    //cout<<"\n\n CMdiff=\n";
 
   //print CMdiff transpose
        for(int ii = 0; ii<CMdiff.size(); ii++)
    {
        {
            //      cout<<CMdiff[ii]<<" ";
            
        }
    }
        //    cout<<"\n\nMat=";

    //print CMdiff transpose
    for(int ii = 0; ii<sz; ii++)
    {
        for(int jj = 0; jj<sz; jj++)
        {   
            {
                Mat[ii*(sizemat-1)+jj] = CMdiff[jj*(sizemat-1)+ii];
          
            }
        }
    }
    /*    cout<<"\n\n Mat=\n";
    
   //print CMdiff transpose
        for(int ii = 0; ii<sz*sz; ii++)
    {
        {
            cout<<Mat[ii]<<" ";
            
        }
    }
    cout<<"\n\n";
    */
    int info = 0;
    
    
    char jobvl = 'N';
    char jobvr = 'N';

    NekDouble dum1, dum2;
    
    Lapack::Dgeev(jobvl,jobvr,sz,Mat.get(),sz,EIG_temp.get(),EIG_I.get(),&dum1,1,&dum2,1,&work1[0],lwork,info);
   
    vector<NekDouble>EIG_R;// (ctr, EIG_temp.data());
    
    for(int k = 0; k < sz; k++)
    {
        //cout<<"\n"<< EIG_temp[k]<<" "<<EIG_I[k];
        if(abs(EIG_I[k])<1e-8 && abs(EIG_temp[k])<=1.0)
        {
            EIG_R.push_back(EIG_temp[k]);
        }
    }
    
    EIG_R.push_back(-1.0);
    EIG_R.push_back(1.0);

    //cout<<"\n eigenvals\n:";

    //for(int ii = 0; ii < EIG_R.size(); ii++)
        //    cout<<EIG_R[ii]<<" ";
    //    cout<<"\n print done\n\n";
    //cout<<"\n print done: EIG_R:"<<EIG_R[0]<<" "<<EIG_R[1]<<"\n\n";

    return EIG_R;
}

int Opt_needed(Array<OneD, NekDouble> uhats)
{

    //    Array<OneD, NekDouble> uhats = E->GetCoeffs();

    
    int dimension = E->GetShapeDimension();

    /*    uhats[0] = -0.003600490035800;
    uhats[1] = -0.003764377492043  ;
    uhats[2] = -0.006054798699253  ;
    uhats[3] =-0.001813736937865  ;
    uhats[4] = -0.001519665754303  ;
    uhats[5] = -0.001698817122805  ;
    uhats[6] =-0.002644373952871;
    uhats[7] = -0.001108665676515  ;
    uhats[8] =0.000655966080148  ;
    uhats[9] = 0.000684672455617  ;
    uhats[10] = 0.001102181410626  ;
    uhats[11] =0.000326846977333;
    uhats[12] =0.000074571955782;
    uhats[13] =0.000082199224769;
    uhats[14] =0.000128822914434;
    uhats[15] =0.000050772186786;*/
    int totModes = uhats.size();
    vector<vector<  NekDouble> > roots;
    cout<<"\n uhats in opt_needed:"<<uhats.size()<<"\n";
    for(int ii = 0; ii<uhats.size(); ii++)
    {
        cout<<uhats[ii]<<" ";
    }
    cout<<"\n\n";

    if( dimension == 2)
    {
        //find edge roots: (edges = 4 = quad, edges = 3 = tri)
        int numedges = E->GetNtraces();
        Array<OneD, Array<OneD, NekDouble> > edgeuhats  (numedges);
        project_edges(uhats, edgeuhats);
        cout<<"\n edgeuhats = "<<edgeuhats.size()<<"\t"<< edgeuhats[0].size();
        //find roots of der of uhats, that is why d = 1
        roots = call_find_roots(uhats, 1, edgeuhats);
        cout<<"\n back!\n\n";
    }
    else if(dimension == 1)
    {
        // find roots of der of uhats, that is why d = 1
        roots = call_find_roots(uhats, 1);
        
        // print roots:
            cout<<"\n roots in opt_needed seg:\n";
              for(int ii = 0; ii<roots.size(); ii++)
              {
              for(int jj = 0; jj<roots[0].size(); jj++)
              {
              cout<<roots[ii][jj]<<" ";
              }
              cout<<"\n";
              }
              cout<<"\n";
        
        // if vector[0].size() is 1, dim = 1...
        
        // convert roots vec to array
        
        
    }   

    Array<OneD, Array<OneD,  NekDouble> > rootsarr(roots.size());
        
        
        for(int ii = 0; ii < roots.size(); ii++)
        {
            rootsarr[ii] = Array<OneD, NekDouble>(roots[ii].size(), roots[ii].data());
        }
 
    // evaluate ortho basis at roots
    // evalBasisRoots is flattened basis eval matrix
    int     evalsz = (roots[0].size())*totModes;
    Array<OneD, NekDouble> evalBasisRoots(evalsz);

    E->PhysEvalBasisGrad(rootsarr, evalBasisRoots, NullNekDouble1DArray, NullNekDouble1DArray, NullNekDouble1DArray);
    Array<OneD, NekDouble> tmp(roots.size());
    
    /*    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        for(int jj = 0; jj <totModes; jj++)
        {
            //            cout<<"\n diededede ii = "<<ii<<"jj = "<<jj<<"roots[0].size()="<<roots[0].size()<<" evlbasroots sz="<<evalBasisRoots.size()<<" totmodes = "<<totModes<<" jj + roots[0].size()*ii = "<<jj + roots[0].size()*ii<<"\n\n";

            for(int kk = 0; kk < roots.size(); kk++)
            {
                tmp[kk] = roots[kk][ii];
            }
            evalBasisRoots[jj + roots[0].size()*ii] = (E->PhysEvaluateBasis(tmp, jj));
        }
    }*/
    

    // vals = evalBasisRoots \times uhats 
    Array<OneD, NekDouble> vals(roots[0].size()), temp(totModes);
    for(int k = 0; k < vals.size(); ++k)
    {

        Vmath::Vmul(totModes, &evalBasisRoots[k], vals.size(), &uhats[0], 1, &temp[0], 1);
        vals[k] = Vmath::Vsum(temp.size(), temp, 1);
        cout<<" vals["<<k<<"]="<<vals[k]<<" ";
    }
 
    NekDouble minv = Vmath::Vmin(vals.size(), vals, 1);	
    cout<<"\n minv = "<<minv<<"\n\n";
    
    if(minv < 0.0 && abs(minv)>1e-10)
    {
        return 1;
    }
    return 0;
}

void pq(
                          Array<OneD,NekDouble> uhats,
                          vector<vector< NekDouble> > roots,
                          Array<OneD,NekDouble> &pqevalxast,
                          Array<OneD,NekDouble> &wsp1)
{

    int N = uhats.size();
    vector< NekDouble> V1;
    vector<NekDouble> Vsumsq, fvals;//(roots[0].size());

    // V1 is flattened basis eval matrix
    // int     evalsz = roots[0].size()*N;
    cout<<"\n optima in pq sz = "<<roots[0].size()<<"\n\n";
    //for(int ii = 0; ii < roots[0].size(); ii++)
    // {
    //    cout<<        roots[0][ii]<<" ";
    // }
    //cout<<"\n";

    // eval basis at roots
    //    cout<<"\n uhats in pq:\n";
    //for(int ii = 0; ii < uhats.size(); ii++)
    //{
    //    cout<<        uhats[ii]<<" ";
    //}
    //cout<<"\n";
    
    for(int ii = 0; ii <  roots[0].size(); ii++)
    {
        for(int jj = 0; jj <N; jj++)
        {
            V1.push_back(E->PhysEvaluateBasis(Array<OneD, NekDouble>(1,roots[0][ii]), jj));
        }
    }

    // V2 = mat_mat_dot(V1,V1);
    // and
    // vector<double> Vsum = mat_sum_dim(V2,2);

    //    cout<<"\n V.*V=\n";
    for( int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &V1[i*N], 1, &wsp1[0], 1);

        Vsumsq.push_back(1.0/pow(Vmath::Vsum(N, &wsp1[0], 1),0.5));
    }
    /*    cout<<"\n cfun(opt)\n:";
    for(int ii = 0; ii<roots[0].size(); ii++)
        cout<<Vsumsq[ii]<<" ";
    cout<<"\n\n";
    */
    //vector<double> mv = mat_vec(V1,uhats);
    //cout<<"\n numerator:\n\n";
    for(int i = 0; i < roots[0].size(); i++)
    {
        Vmath::Vmul(N, &V1[i*N], 1, &uhats[0], 1, &wsp1[0], 1);
        fvals.push_back( Vmath::Vsum(N, &wsp1[0], 1));
        //cout<<fvals[i]<<" ";

    }

    //cout<<"\n\n";
    //    cts = vec_vec_dot(Vsumsq, ret);
    Vmath::Vmul(roots[0].size(), &Vsumsq[0], 1, &fvals[0], 1, &fvals[0], 1);
    //    cout<<"\n pq returns:\n";

    //for(int i = 0; i < roots[0].size(); i++)
    //{
    //    cout<<fvals[i]<<" ";
    //}
    //cout<<"\n\n";

    int minidx = Vmath::Imin(fvals.size(), &fvals[0], 1);
    pqevalxast[0] = fvals[minidx];
    pqevalxast[1] = roots[0][minidx];
    //    cout<<"\n pq returns:\n";
    //cout<<"pqeval = "<< pqevalxast[0] <<" xast = "<< pqevalxast[1]<<"\n\n";   

}


void Do_optimize(Array<OneD, NekDouble> &uhats)
{

    // uhats[0] =  0.331730709814333;
    // uhats[1] =   0.459076341659940;
    // uhats[2] =   0.363919276512675;
    // uhats[3] =  -0.056672051052144;

    double inf = numeric_limits<double>::infinity();
    //assert(size(constraints, 1) == N+2);
    int N1 = uhats.size();
    vector<Array<OneD,NekDouble> > d;
    d.push_back(uhats);
    int counter = 0;

    //    int NC = ck[1].size();          // number of constraints
    vector<double> tols;         // constraint specific tolerances

    int niter = 1e3;
    vector< vector<NekDouble> > optima;
    
    //    int NC = 1; //number of constraints, only positivity for now
    tols.push_back(1e-10);
    Array<OneD, NekDouble>  pqvalxast(2), xastarr(1),Pf, utemp, wsp1(N1);   
 
   //    Array<OneD, Array<OneD, NekDouble> >;
    NekDouble pqval,  xast;//, minel;// minidx;
  
   while (counter <= niter)
    {
        
        pqval = inf;
        xast = 0;
        //cout<<"\n counter = "<<counter<<"\n\n";       
        utemp = d.back();
        cout<<"\n at counter "<<counter<<" init uhats = ";
        for(int kk = 0; kk < N1; kk++)
            cout<<utemp[kk]<<" ";
        //cout<<"\n";
        //pq = @(xx) cfun(xx) .* (constraints(1,jj).*Vc(xx)*uhats);     
        cout<<"\n qwmore sz = "<<qwmore.size()<<"\n\n";

        Pf = uhatpqd(utemp, qwmore, V, Vd, V3);
                        cout<<"\n Pf:\n\n";
                for(int kk = 0; kk <Pf.size(); kk++)
                    cout<<Pf[kk]<<" ";
        optima = (call_find_roots(Pf));
        
        cout<<"\n uhatpqd: ";
        for(int ii = 0; ii<Pf.size(); ii++)
            cout<<Pf[ii]<<" ";
        cout<<"\n";

        pq(utemp, optima, pqvalxast, wsp1);
                
        //cout<<"\n pq returns:\n\n";
        //cout<<"pqval = "<< pqvalxast[0] <<" xast = "<< pqvalxast[1]<<"pqval = "<<pqval<<"\n\n";   

        if (pqvalxast[0] < pqval)
        {
            xast = pqvalxast[1];//optima[0][minidx];
            pqval = pqvalxast[0];
            //jval = jj; //<- use for multiple constraints
        }
        
        
        //}
        
        //        cout<<"\n pqval="<<pqval<<" xast ="<<xast<<"\n\n";
        // If minimum is non-negative, we're done
        if (pqval >= -tols.at(0))
        {
            break;
        }
        
        xastarr[0] = xast;
        vector<NekDouble> Vastsq;
        vector<NekDouble> Vast;
        
        NekDouble vastsqsum;
        
        //Vast= poly_eval(xastv,N1,ck[1][jval]);
        //Vastsq = mat_mat_dot(Vast,Vast);
        //cout<<"\n N1 = "<<N1<<"\n";
        for( int ii = 0; ii < N1; ii++)
        {
            Vast.push_back(E->PhysEvaluateBasis(xastarr, ii));
            Vastsq.push_back(Vast[ii]*Vast[ii]);
        
        }
        
        //Vmath::Vmul(N1, &Vast[0], 1, &Vast[0], 1, &Vastsq[0], 1);
        vastsqsum = Vmath::Vsum(N1, &Vastsq[0], 1);

        Array<OneD, NekDouble>  qast(N1);

        for(int i = 0; i<N1; i++)
        {
            qast[i] = ((1/sqrt(vastsqsum))*(Vast[i]));
        }
        Vmath::Smul(N1, pqval, &qast[0], 1, &qast[0], 1);
        
        Vmath::Vsub(utemp.size(), &utemp[0], 1, &qast[0], 1, &qast[0], 1);
        d.push_back(qast);

        cout<<"\n at counter = "<<counter<<" final uhats:;\n";
        for(int ii = 0; ii < qast.size(); ii++)
            cout<<qast[ii]<<" ";
        cout<<"\n";

        counter = counter + 1;
    
    
    }
    cout<<"sphere_rotation took "<<counter<<"  iterations\n ";
    uhats = d.back();       
    cout<<"\n do_opt returning uhats\n";
    for(int ii = 0; ii < uhats.size(); ii++)
        cout<<uhats[ii]<<" ";
    cout<<"\n";
}


Array<OneD, NekDouble > uhatpqd(
                                        Array<OneD, NekDouble > c, 
                                        Array<OneD, NekDouble > qw, 
                                        Array<OneD, NekDouble > V,
                                        Array<OneD, NekDouble > Vd,
                                        Array<OneD, NekDouble > V3
                                        )
{

    Array<OneD, NekDouble > ret(c.size()), temp(qw.size()), pqeval(qw.size());
    //pqeval = -(sum(V(:,:,1+d).*V(:,:,2+d), 2)).*(V(:,:,1+d)*c) + (sum(V(:,:,1+d).*V(:,:,1+d), 2)).*(V(:,:,2+d)*c);
    
    cout<<"\n Vd = \n";       
    for(int ii = 0; ii<Vd.size(); ii++)
        cout<<Vd[ii]<<" ";
    cout<<"\n";

    //Vd*c
    cout<<"\n Vd*c=\n";
    for(int i = 0; i < qw.size(); i++)
    {
        Vmath::Vmul(c.size(), &Vd[i], qw.size(), &c[0], 1, &ret[0], 1);
        temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
        cout<<" "<<temp[i];
    }

    //temp * sum(V.*V,2)
    cout<<"\n prev*sum(V.*V,2:\n";
    //    cout<<"\n pqeval:\n";
    for(int i = 0; i < qw.size(); i++)
    {
        Vmath::Vmul(c.size(), &V[i], qw.size(), &V[i], qw.size(), &ret[0], 1);
        //cout<<" "<< Vmath::Vsum(c.size(), &ret[0], 1);
    
        pqeval[i] = temp[i] * Vmath::Vsum(c.size(), &ret[0], 1);
        cout<<pqeval[i]<<" ";
    
    }

    //V*c
    //    cout<<"\nVc\n";
    for(int i = 0; i < qw.size(); i++)
    {
        Vmath::Vmul(c.size(), &V[i], qw.size(), &c[0], 1, &ret[0], 1);
        temp[i] = Vmath::Vsum(c.size(), &ret[0], 1);
        // cout<<temp[i]<<" ";
    }

    //temp*sum(V.*Vd,2)
        cout<<"\n temp*sum(V.*Vd,2):\n";
    for(int i = 0; i < qw.size(); i++)
    {
        Vmath::Vmul(c.size(), &V[i], qw.size(), &Vd[i], qw.size(), &ret[0], 1);
        NekDouble tt= (Vmath::Vsum(c.size(), &ret[0], 1));
        pqeval[i] =  pqeval[i] - temp[i] * tt;
        cout<<tt<<" ";
    }
        cout<<"\n";
    
    //pqeval = vec_vec_dot(pqeval, qw);

    /*cout<<"\n pqeval ="<<pqeval.size()<<"\n";
    for(int ii = 0; ii<pqeval.size(); ii++)
        cout<<pqeval[ii]<<" ";
    cout<<"\n qw ="<<qw.size()<<"\n";
    for(int ii = 0; ii<qw.size(); ii++)
        cout<<qw[ii]<<" ";
    */
    Vmath::Vmul(qw.size(), &pqeval[0], 1, &qw[0], 1, &pqeval[0], 1);
    Array<OneD, NekDouble> rettemp(qw.size()), rettemp2(qw.size());
    //    ret = mat_vec(mat_T(V3),ret);
     cout<<"\n uhatpqd:";
    for(int i = 0; i < qw.size(); i++)
    {
        Vmath::Vmul(qw.size(), &pqeval[0], 1, &V3[0]+i*qw.size(), 1, &rettemp[0], 1 );
        rettemp2[i] = Vmath::Vsum(qw.size(), &rettemp[0], 1);
         cout<<rettemp2[i]<<" ";
    }
    //cout<<"\n\n";

    return rettemp2;
}



NekDouble Shape_sol(NekDouble x, NekDouble y, NekDouble z, vector<int> order,
                    vector<BasisType> btype, ShapeType stype, bool diff)
{
    map<ShapeType, function<int(int, const vector<int> &)>> shapeConstraint2;
    shapeConstraint2[ePoint] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eSegment] =
            [](int,   const vector<int> &     ) { return 1; };
    shapeConstraint2[eTriangle] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[eQuadrilateral] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eTetrahedron] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePyramid] =
            [](int k, const vector<int> &order) { return order[1] - k; };
    shapeConstraint2[ePrism] =
            [](int,   const vector<int> &order) { return order[1]; };
    shapeConstraint2[eHexahedron] =
            [](int,   const vector<int> &order) { return order[1]; };

    map<ShapeType, function<int(int, int, const vector<int> &order)>>
            shapeConstraint3;
    shapeConstraint3[ePoint] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eSegment] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTriangle] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eQuadrilateral] =
            [](int,   int,   const vector<int> &     ) { return 1; };
    shapeConstraint3[eTetrahedron] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePyramid] =
            [](int k, int l, const vector<int> &order) { return order[2] - k - l; };
    shapeConstraint3[ePrism] =
            [](int k, int,   const vector<int> &order) { return order[2] - k; };
    shapeConstraint3[eHexahedron] =
            [](int,   int,   const vector<int> &order) { return order[2]; };

    NekDouble sol = 0.0;
    if (!diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += sin(k * M_PI * x) + cos(k * M_PI * x);
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eSegment)
        {
            sol += 0.25 * sin(M_PI * x) + 0.25 * cos(M_PI * x);
        }
        else if (btype[0] == eFourier && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1] / 2; ++l)
                    {
                        sol += sin(k * M_PI * x) * sin(l * M_PI * y) +
                               sin(k * M_PI * x) * cos(l * M_PI * y) +
                               cos(k * M_PI * x) * sin(l * M_PI * y) +
                               cos(k * M_PI * x) * cos(l * M_PI * y);
                    }
                }
            }
            else if (btype[1] == eFourierSingleMode)
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    sol += sin(k * M_PI * x) * sin(M_PI * y) +
                           sin(k * M_PI * x) * cos(M_PI * y) +
                           cos(k * M_PI * x) * sin(M_PI * y) +
                           cos(k * M_PI * x) * cos(M_PI * y);
                }
            }
            else
            {
                for (int k = 0; k < order[0] / 2; ++k)
                {
                    for (int l = 0; l < order[1]; ++l)
                    {
                        sol += sin(k * M_PI * x) * pow_loc(y, l) +
                               cos(k * M_PI * x) * pow_loc(y, l) ;
                    }
                }
            }
        }
        else if (btype[0] == eFourierSingleMode && stype == eQuadrilateral)
        {
            if (btype[1] == eFourier)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(M_PI * x) * sin(l * M_PI * y) +
                           sin(M_PI * x) * cos(l * M_PI * y) +
                           cos(M_PI * x) * sin(l * M_PI * y) +
                           cos(M_PI * x) * cos(l * M_PI * y);
                }

            }
            else if (btype[1] == eFourierSingleMode)
            {
                sol += sin(M_PI * x) * sin(M_PI * y) +
                       sin(M_PI * x) * cos(M_PI * y) +
                       cos(M_PI * x) * sin(M_PI * y) +
                       cos(M_PI * x) * cos(M_PI * y);
            }
            else
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += sin(M_PI * x) * pow_loc(y, l) +
                           cos(M_PI * x) * pow_loc(y, l);
                }
            }
        }
        else if (btype[1] == eFourier && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += sin(l * M_PI * y) * pow_loc(x, k) +
                           cos(l * M_PI * y) * pow_loc(x, k);
                }
            }
        }
        else if (btype[1] == eFourierSingleMode && stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                sol += sin(M_PI * y) * pow_loc(x, k) +
                       cos(M_PI * y) * pow_loc(x, k);
            }
        }
        else
        {
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        sol += pow_loc(x, k) * pow_loc(y, l) * pow_loc(z, m);
                    }
                }
            }
        }
    }
    else if (diff)
    {
        if (btype[0] == eFourier && stype == eSegment)
        {
            for (int k = 0; k < order[0] / 2 - 1; ++k)
            {
                sol += k * M_PI * (cos(k * M_PI * z) - sin(k * M_PI * z));
            }
        }
        else if (btype[0] != eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0]; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += k * pow_loc(x, k - 1) * sin(M_PI * l * y)
                           + M_PI * l * pow_loc(x, k) * cos(M_PI * l * y) +
                           +k * pow_loc(x, k - 1) * cos(M_PI * l * y)
                           - M_PI * l * pow_loc(x, k) * sin(M_PI * l * y);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] != eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1]; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1) +
                           -M_PI * k * sin(M_PI * k * x) * pow_loc(y, l)
                           + l * sin(M_PI * k * x) * pow_loc(y, l - 1);
                }
            }
        }
        else if (btype[0] == eFourier && btype[1] == eFourier &&
                 stype == eQuadrilateral)
        {
            for (int k = 0; k < order[0] / 2; ++k)
            {
                for (int l = 0; l < order[1] / 2; ++l)
                {
                    sol += M_PI * k * cos(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * sin(M_PI * k * x) * cos(M_PI * l * y)
                           + M_PI * k * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * sin(M_PI * k * x) * sin(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * sin(M_PI * l * y)
                           + M_PI * l * cos(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * k * sin(M_PI * k * x) * cos(M_PI * l * y)
                           - M_PI * l * cos(M_PI * k * x) * sin(M_PI * l * y);
                }
            }
        }
        else
        {
            NekDouble a;
            for (int k = 0;
                 k < order[0]; ++k) //ShapeConstraint 1 is always < order1
            {
                for (int l = 0; l < shapeConstraint2[stype](k, order); ++l)
                {
                    for (int m = 0;
                         m < shapeConstraint3[stype](k, l, order); ++m)
                    {
                        a = k * pow_loc(x, k - 1) * pow_loc(y, l) *
                            pow_loc(z, m);
                        sol += a;
                        a = l * pow_loc(x, k) * pow_loc(y, l - 1) *
                            pow_loc(z, m);
                        sol += a;
                        a = m * pow_loc(x, k) * pow_loc(y, l) *
                            pow_loc(z, m - 1);
                        sol += a;
                    }
                }
            }
        }
    }

    return sol;
}
